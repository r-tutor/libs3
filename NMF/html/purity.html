<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Purity and Entropy of a Clustering</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for purity {NMF}"><tr><td>purity {NMF}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Purity and Entropy of a Clustering</h2>

<h3>Description</h3>

<p>The functions <code>purity</code> and <code>entropy</code>
respectively compute the purity and the entropy of a
clustering given <em>a priori</em> known classes.
</p>
<p>The purity and entropy measure the ability of a
clustering method, to recover known classes (e.g. one
knows the true class labels of each sample), that are
applicable even when the number of cluster is different
from the number of known classes. <cite>Kim et al.
(2007)</cite> used these measures to evaluate the performance
of their alternate least-squares NMF algorithm.
</p>


<h3>Usage</h3>

<pre>
  purity(x, y, ...)

  entropy(x, y, ...)

  ## S4 method for signature 'NMFfitXn,ANY'
purity(x, y, method = "best",
    ...)

  ## S4 method for signature 'NMFfitXn,ANY'
entropy(x, y, method = "best",
    ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>an object that can be interpreted as a factor or
can generate such an object, e.g. via a suitable method
<code><a href="predict.html">predict</a></code>, which gives the cluster membership
for each sample.</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>a factor or an object coerced into a factor that
gives the true class labels for each sample. It may be
missing if <code>x</code> is a contingency table.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>extra arguments to allow extension, and
usually passed to the next method.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>a character string that specifies how the
value is computed. It may be either <code>'best'</code> or
<code>'mean'</code> to compute the best or mean purity
respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose we are given <i>l</i> categories, while the
clustering method generates <i>k</i> clusters.
</p>
<p>The purity of the clustering with respect to the known
categories is given by: </p>
<p style="text-align: center;"><i>Purity = \frac{1}{n}
  &sum;_{q=1}^k \max_{1 &le;q j &le;q l} n_q^j</i></p>
<p> ,
</p>
<p>where: </p>
 <ul>
<li> <p><i>n</i> is the total number of
samples; </p>
</li>
<li> <p><i>n_q^j</i> is the number of samples in
cluster <i>q</i> that belongs to original class <i>j</i>
(<i>1 &le;q j &le;q l</i>). </p>
</li></ul>

<p>The purity is therefore a real number in <i>[0,1]</i>. The
larger the purity, the better the clustering performance.
</p>
<p>The entropy of the clustering with respect to the known
categories is given by: </p>
<p style="text-align: center;"><i> - 1/(n log2(l) ) sum_q sum_j n(q,j)
  log2( n(q,j) / n_q )</i></p>
<p>,
</p>
<p>where: </p>
 <ul>
<li> <p><i>n</i> is the total number of
samples; </p>
</li>
<li> <p><i>n_q</i> is the total number of
samples in cluster <i>q</i> (<i>1 &le;q q &le;q k</i>); </p>
</li>
<li>
<p><i>n(q,j)</i> is the number of samples in cluster
<i>q</i> that belongs to original class <i>j</i> (<i>1
  &le;q j &le;q l</i>). </p>
</li></ul>

<p>The smaller the entropy, the better the clustering
performance.
</p>


<h3>Value</h3>

<p>a single numeric value
</p>
<p>the entropy (i.e. a single numeric value)
</p>


<h3>Methods</h3>


<dl>
<dt>entropy</dt><dd><p><code>signature(x = "table", y =
  "missing")</code>: Computes the purity directly from the
contingency table <code>x</code>.
</p>
<p>This is the workhorse method that is eventually called by
all other methods. </p>
</dd>
<dt>entropy</dt><dd><p><code>signature(x = "factor", y = "ANY")</code>:
Computes the purity on the contingency table of <code>x</code>
and <code>y</code>, that is coerced into a factor if necessary.
</p>
</dd>
<dt>entropy</dt><dd><p><code>signature(x = "ANY", y = "ANY")</code>:
Default method that should work for results of clustering
algorithms, that have a suitable <code>predict</code> method
that returns the cluster membership vector: the purity is
computed between <code>x</code> and <code>predict{y}</code> </p>
</dd>
<dt>entropy</dt><dd><p><code>signature(x = "NMFfitXn", y =
  "ANY")</code>: Computes the best or mean entropy across all NMF
fits stored in <code>x</code>. </p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "table", y =
  "missing")</code>: Computes the purity directly from the
contingency table <code>x</code> </p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "factor", y = "ANY")</code>:
Computes the purity on the contingency table of <code>x</code>
and <code>y</code>, that is coerced into a factor if necessary.
</p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "ANY", y = "ANY")</code>:
Default method that should work for results of clustering
algorithms, that have a suitable <code>predict</code> method
that returns the cluster membership vector: the purity is
computed between <code>x</code> and <code>predict{y}</code> </p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "NMFfitXn", y =
  "ANY")</code>: Computes the best or mean purity across all NMF
fits stored in <code>x</code>. </p>
</dd>
</dl>



<h3>References</h3>

<p>Kim H and Park H (2007). &quot;Sparse non-negative matrix
factorizations via alternating non-negativity-constrained
least squares for microarray data analysis.&quot;
_Bioinformatics (Oxford, England)_, *23*(12), pp.
1495-502. ISSN 1460-2059, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btm134&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/17483501&gt;.
</p>


<h3>See Also</h3>

<p>Other assess: <code><a href="sparseness.html">sparseness</a></code>
</p>


<h3>Examples</h3>

<pre>


# generate a synthetic dataset with known classes: 50 features, 18 samples (5+5+8)
n &lt;- 50; counts &lt;- c(5, 5, 8);
V &lt;- syntheticNMF(n, counts)
cl &lt;- unlist(mapply(rep, 1:3, counts))

# perform default NMF with rank=2
x2 &lt;- nmf(V, 2)
purity(x2, cl)
entropy(x2, cl)
# perform default NMF with rank=2
x3 &lt;- nmf(V, 3)
purity(x3, cl)
entropy(x3, cl)
</pre>

<hr /><div style="text-align: center;">[Package <em>NMF</em> version 0.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
