<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Structure for Storing All Fits from Multiple NMF Runs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for NMFfitXn-class {NMF}"><tr><td>NMFfitXn-class {NMF}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Structure for Storing All Fits from Multiple NMF Runs</h2>

<h3>Description</h3>

<p>This class is used to return the result from a multiple
run of a single NMF algorithm performed with function
<code>nmf</code> with option <code>keep.all=TRUE</code> (cf.
<code><a href="nmf.html">nmf</a></code>).
</p>


<h3>Details</h3>

<p>It extends both classes <code><a href="NMFfitX-class.html">NMFfitX</a></code> and
<code>list</code>, and stores the result of each run (i.e. a
<code>NMFfit</code> object) in its <code>list</code> structure.
</p>
<p>IMPORTANT NOTE: This class is designed to be
<strong>read-only</strong>, even though all the
<code>list</code>-methods can be used on its instances. Adding
or removing elements would most probably lead to
incorrect results in subsequent calls. Capability for
concatenating and merging NMF results is for the moment
only used internally, and should be included and
supported in the next release of the package.
</p>


<h3>Slots</h3>


<dl>
<dt>.Data</dt><dd><p>standard slot that contains the S3
<code>list</code> object data. See R documentation on S3/S4
classes for more details (e.g.,
<code><a href="../../methods/html/setOldClass.html">setOldClass</a></code>).</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the name of the common NMF algorithm used to
compute all fits stored in <code>object</code>
</p>
<p>Since all fits are computed with the same algorithm, this
method returns the name of algorithm that computed the
first fit. It returns <code>NULL</code> if the object is empty.
</p>
</dd>
<dt>basis</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the basis matrix of the best fit amongst all the
fits stored in <code>object</code>. It is a shortcut for
<code>basis(fit(object))</code>. </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the coefficient matrix of the best fit amongst
all the fits stored in <code>object</code>. It is a shortcut
for <code>coef(fit(object))</code>. </p>
</dd>
<dt>compare</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Compares the fits obtained by separate runs of NMF, in a
single call to <code><a href="nmf.html">nmf</a></code>. </p>
</dd>
<dt>consensus</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
This method returns <code>NULL</code> on an empty object. The
result is a matrix with several attributes attached, that
are used by plotting functions such as
<code><a href="heatmaps.html">consensusmap</a></code> to annotate the plots. </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "NMFfitXn")</code>: Returns the
dimension common to all fits.
</p>
<p>Since all fits have the same dimensions, it returns the
dimension of the first fit. This method returns
<code>NULL</code> if the object is empty. </p>
</dd>
<dt>entropy</dt><dd><p><code>signature(x = "NMFfitXn", y =
  "ANY")</code>: Computes the best or mean entropy across all NMF
fits stored in <code>x</code>. </p>
</dd>
<dt>fit</dt><dd><p><code>signature(object = "NMFfitXn")</code>: Returns
the best NMF fit object amongst all the fits stored in
<code>object</code>, i.e. the fit that achieves the lowest
estimation residuals. </p>
</dd>
<dt>.getRNG</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the RNG settings used for the best fit.
</p>
<p>This method throws an error if the object is empty. </p>
</dd>
<dt>getRNG1</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the RNG settings used for the first run.
</p>
<p>This method throws an error if the object is empty. </p>
</dd>
<dt>minfit</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the best NMF model in the list, i.e. the run that
achieved the lower estimation residuals.
</p>
<p>The model is selected based on its <code>deviance</code> value.
</p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the common type NMF model of all fits stored in
<code>object</code>
</p>
<p>Since all fits are from the same NMF model, this method
returns the model type of the first fit. It returns
<code>NULL</code> if the object is empty. </p>
</dd>
<dt>nbasis</dt><dd><p><code>signature(x = "NMFfitXn")</code>: Returns
the number of basis components common to all fits.
</p>
<p>Since all fits have been computed using the same rank, it
returns the factorization rank of the first fit. This
method returns <code>NULL</code> if the object is empty. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the number of runs performed to compute the fits
stored in the list (i.e. the length of the list itself).
</p>
</dd>
<dt>purity</dt><dd><p><code>signature(x = "NMFfitXn", y =
  "ANY")</code>: Computes the best or mean purity across all NMF
fits stored in <code>x</code>. </p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
If no time data is available from in slot
&lsquo;runtime.all&rsquo; and argument <code>null=TRUE</code>, then
the sequential time as computed by <code><a href="algorithmic.html">seqtime</a></code>
is returned, and a warning is thrown unless
<code>warning=FALSE</code>. </p>
</dd>
<dt>seeding</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the name of the common seeding method used the
computation of all fits stored in <code>object</code>
</p>
<p>Since all fits are seeded using the same method, this
method returns the name of the seeding method used for
the first fit. It returns <code>NULL</code> if the object is
empty. </p>
</dd>
<dt>seqtime</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the CPU time that would be required to
sequentially compute all NMF fits stored in
<code>object</code>.
</p>
<p>This method calls the function <code>runtime</code> on each fit
and sum up the results. It returns <code>NULL</code> on an
empty object. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "NMFfitXn")</code>: Show
method for objects of class <code>NMFfitXn</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other multipleNMF: <code><a href="NMFfitX1-class.html">NMFfitX1-class</a></code>,
<code><a href="NMFfitX-class.html">NMFfitX-class</a></code>
</p>


<h3>Examples</h3>

<pre>


# generate a synthetic dataset with known classes
n &lt;- 20; counts &lt;- c(5, 2, 3);
V &lt;- syntheticNMF(n, counts)

# get the class factor
groups &lt;- V$pData$Group

# perform multiple runs of one algorithm, keeping all the fits
res &lt;- nmf(V, 3, nrun=3, .options='k') # .options=list(keep.all=TRUE) also works
res

summary(res)
# get more info
summary(res, target=V, class=groups)

# compute/show computational times
runtime.all(res)
seqtime(res)

# plot the consensus matrix, computed on the fly
## Not run:  consensusmap(res, annCol=groups) 
</pre>

<hr /><div style="text-align: center;">[Package <em>NMF</em> version 0.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
