<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Running NMF algorithms</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for nmf {NMF}"><tr><td>nmf {NMF}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Running NMF algorithms</h2>

<h3>Description</h3>

<p>The function <code>nmf</code> is a S4 generic defines the main
interface to run NMF algorithms within the framework
defined in package <code>NMF</code>. It has many methods that
facilitates applying, developing and testing NMF
algorithms.
</p>
<p>The package vignette <code>vignette('NMF')</code> contains an
introduction to the interface, through a sample data
analysis.
</p>


<h3>Usage</h3>

<pre>
  nmf(x, rank, method, ...)

  ## S4 method for signature 'matrix,numeric,NULL'
nmf(x, rank, method,
    seed = NULL, model = NULL, ...)

  ## S4 method for signature 'matrix,numeric,list'
nmf(x, rank, method, ...,
    .parameters = list())

  ## S4 method for signature 'matrix,numeric,function'
nmf(x, rank, method,
    seed, model = "NMFstd", ..., name,
    objective = "euclidean", mixed = FALSE)

  ## S4 method for signature 'matrix,NMF,ANY'
nmf(x, rank, method, seed,
    ...)

  ## S4 method for signature 'matrix,NULL,ANY'
nmf(x, rank, method, seed,
    ...)

  ## S4 method for signature 'matrix,matrix,ANY'
nmf(x, rank, method, seed,
    model = list(), ...)

  ## S4 method for signature 'formula,ANY,ANY'
nmf(x, rank, method, ...,
    model = NULL)

  ## S4 method for signature 'matrix,numeric,NMFStrategy'
nmf(x, rank,
    method, seed = nmf.getOption("default.seed"),
    rng = NULL, nrun = if (length(rank) &gt; 1) 30 else 1,
    model = NULL, .options = list(),
    .pbackend = nmf.getOption("pbackend"),
    .callback = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>target data to fit, i.e. a matrix-like object</p>
</td></tr>
<tr valign="top"><td><code>rank</code></td>
<td>
<p>specification of the factorization rank. It
is usually a single numeric value, but other type of
values are possible (e.g. matrix), for which specific
methods are implemented. See for example methods
<code>nmf,matrix,matrix,ANY</code>.
</p>
<p>If <code>rank</code> is a numeric vector with more than one
element, e.g. a range of ranks, then <code><a href="nmf.html">nmf</a></code>
performs the estimation procedure described in
<code><a href="nmfEstimateRank.html">nmfEstimateRank</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>specification of the NMF algorithm. The
most common way of specifying the algorithm is to pass
the access key (i.e. a character string) of an algorithm
stored in the package's dedicated registry, but methods
exists that handle other types of values, such as
<code>function</code> or <code>list</code> object. See their
descriptions in section <em>Methods</em>.
</p>
<p>If <code>method</code> is missing the algorithm to use is
obtained from the option
<code>nmf.getOption('default.algorithm')</code>, unless it can
be infer from the type of NMF model to fit, if this later
is available from other arguments. Factory fresh default
value is &lsquo;brunet&rsquo;, which corresponds to the
standard NMF algorithm from <cite>Brunet2004</cite> (see
section <em>Algorithms</em>).
</p>
<p>Cases where the algorithm is inferred from the call are
when an NMF model is passed in arguments <code>rank</code> or
<code>seed</code> (see description for
<code>nmf,matrix,numeric,NULL</code> in section
<em>Methods</em>).</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>extra arguments to allow extension of the
generic. Arguments that are not used in the chain of
internal calls to <code>nmf</code> methods are passed to the
function that effectively implements the algorithm that
fits an NMF model on <code>x</code>.</p>
</td></tr>
<tr valign="top"><td><code>.parameters</code></td>
<td>
<p>list of method-specific parameters.
Its elements must have names matching a single method
listed in <code>method</code>, and be lists of named values
that are passed to the corresponding method.</p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>name associated with the NMF algorithm
implemented by the function <code>method</code> [only used when
<code>method</code> is a function].</p>
</td></tr>
<tr valign="top"><td><code>objective</code></td>
<td>
<p>specification of the objective function
associated with the algorithm implemented by the function
<code>method</code> [only used when <code>method</code> is a
function].
</p>
<p>It may be either <code>'euclidean'</code> or <code>'KL'</code> for
specifying the euclidean distance (Frobenius norm) or the
Kullback-Leibler divergence respectively, or a function
with signature <code>(x="NMF", y="matrix", ...)</code> that
computes the objective value for an NMF model <code>x</code> on
a target matrix <code>y</code>, i.e. the residuals between the
target matrix and its NMF estimate. Any extra argument
may be specified, e.g. <code>function(x, y, alpha,
  beta=2, ...)</code>.</p>
</td></tr>
<tr valign="top"><td><code>mixed</code></td>
<td>
<p>a logical that indicates if the algorithm
implemented by the function <code>method</code> support
mixed-sign target matrices, i.e. that may contain
negative values [only used when <code>method</code> is a
function].</p>
</td></tr>
<tr valign="top"><td><code>seed</code></td>
<td>
<p>specification of the starting point or
seeding method, which will compute a starting point,
usually using data from the target matrix in order to
provide a good guess.
</p>
<p>The seeding method may be specified in the following way:
</p>

<dl>
<dt>a <code>character</code> string:</dt><dd><p> giving the name of a
<em>registered</em> seeding method. The corresponding
method will be called to compute the starting point.
</p>
<p>Available methods can be listed via <code>nmfSeed()</code>. See
its dedicated documentation for details on each available
registered methods (<code><a href="nmfSeed.html">nmfSeed</a></code>). </p>
</dd>
<dt>a <code>list</code>:</dt><dd><p> giving the name of a
<em>registered</em> seeding method and, optionally, extra
parameters to pass to it.</p>
</dd>
<dt>a single <code>numeric</code>:</dt><dd><p> that is used to seed the
random number generator, before generating a random
starting point.
</p>
<p>Note that when performing multiple runs, the L'Ecuyer's
RNG is used in order to produce a sequence of random
streams, that is used in way that ensures that parallel
computation are fully reproducible. </p>
</dd>
<dt>an object that inherits from
<code><a href="NMF-class.html">NMF</a></code>:</dt><dd><p> it should contain the data of
an initialised NMF model, i.e. it must contain valid
basis and mixture coefficient matrices, directly usable
by the algorithm's workhorse function.</p>
</dd>
<dt>a <code>function</code>:</dt><dd><p> that computes the starting
point. It must have signature <code>(object="NMF",
  target="matrix", ...)</code> and return an object that inherits
from class <code>NMF</code>. It is recommended to use argument
<code>object</code> as a template for the returned object, by
only updating the basis and coefficient matrices, using
<code><a href="basis-coef-methods.html">basis&lt;-</a></code> and <code><a href="basis-coef-methods.html">coef&lt;-</a></code>
respectively. </p>
</dd>
</dl>
</td></tr>
<tr valign="top"><td><code>rng</code></td>
<td>
<p>rng specification for the run(s). This
argument should be used to set the the RNG seed, while
still specifying the seeding method argument <var>seed</var>.</p>
</td></tr>
<tr valign="top"><td><code>model</code></td>
<td>
<p>specification of the type of NMF model to
use.
</p>
<p>It is used to instantiate the object that inherits from
class <code><a href="NMF-class.html">NMF</a></code>, that will be passed to
the seeding method. The following values are supported:
</p>

<ul>
<li> <p><code>NULL</code>, the default model associated to the
NMF algorithm is instantiated and <code>...</code> is looked-up
for arguments with names that correspond to slots in the
model class, which are passed to the function
<code><a href="nmfModel.html">nmfModel</a></code> to instantiate the model.
Arguments in <code>...</code> that do not correspond to slots
are passed to the algorithm.
</p>
</li>
<li><p> a single <code>character</code> string, that is the name
of the NMF model class to be instantiate.  In this case,
arguments in <code>...</code> are handled in the same way as
when <code>model</code> is <code>NULL</code>.
</p>
</li>
<li><p> a <code>list</code> that contains named values that are
passed to the function <code><a href="nmfModel.html">nmfModel</a></code> to
instantiate the model.  In this case, <code>...</code> is not
looked-up at all, and passed entirely to the algorithm.
This means that all necessary model parameters must be
specified in <code>model</code>.
</p>
</li></ul>

<p><strong>Argument/slot conflicts:</strong> In the case a parameter
of the algorithm has the same name as a model slot, then
<code>model</code> MUST be a list &ndash; possibly empty &ndash;, if one
wants this parameter to be effectively passed to the
algorithm.
</p>
<p>If a variable appears in both arguments <code>model</code> and
<code>...</code>, the former will be used to initialise the
NMF model, the latter will be passed to the NMF
algorithm.  See code examples for an illustration of this
situation.</p>
</td></tr>
<tr valign="top"><td><code>nrun</code></td>
<td>
<p>number of runs to perform. It specifies the
number of runs to perform. By default only one run is
performed, except if <code>rank</code> is a numeric vector with
more than one element, in which case a default of 30 runs
per value of the rank are performed, allowing the
computation of a consensus matrix that is used in
selecting the appropriate rank (see
<code><a href="connectivity.html">consensus</a></code>).
</p>
<p>When using a random seeding method, multiple runs are
generally required to achieve stability and avoid
<em>bad</em> local minima.</p>
</td></tr>
<tr valign="top"><td><code>.options</code></td>
<td>
<p>this argument is used to set runtime
options.
</p>
<p>It can be a <code>list</code> containing named options with
their values, or, in the case only boolean/integer
options need to be set, a character string that specifies
which options are turned on/off or their value, in a
unix-like command line argument way.
</p>
<p>The string must be composed of characters that correspond
to a given option (see mapping below), and modifiers '+'
and '-' that toggle options on and off respectively. E.g.
<code>.options='tv'</code> will toggle on options <code>track</code>
and <code>verbose</code>, while <code>.options='t-v'</code> will
toggle on option <code>track</code> and toggle off option
<code>verbose</code>.
</p>
<p>Modifiers '+' and '-' apply to all option character found
after them: <code>t-vp+k</code> means <code>track=TRUE</code>,
<code>verbose=parallel=FALSE</code>, and <code>keep.all=TRUE</code>.
The default behaviour is to assume that <code>.options</code>
starts with a '+'.
</p>
<p>for options that accept integer values, the value may be
appended to the option's character e.g. <code>'p4'</code> for
asking for 4 processors or <code>'v3'</code> for showing
verbosity message up to level 3.
</p>
<p>The following options are available (the characters after
&ldquo;-&rdquo; are those to use to encode <code>.options</code> as
a string): </p>

<dl>
<dt>debug - d</dt><dd><p> Toggle debug mode (default:
<code>FALSE</code>). Like option <code>verbose</code> but with more
information displayed.</p>
</dd>
<dt>keep.all - k</dt><dd><p> used when performing multiple runs
(<code>nrun</code>&gt;1): if <code>TRUE</code>, all factorizations are
saved and returned (default: <code>FALSE</code>). Otherwise
only the factorization achieving the minimum residuals is
returned.</p>
</dd>
<dt>parallel - p</dt><dd><p> this option is useful on multicore
*nix or Mac machine only, when performing multiple runs
(<code>nrun</code> &gt; 1) (default: <code>TRUE</code>). If <code>TRUE</code>,
the runs are performed using the parallel foreach backend
defined in argument <code>.pbackend</code>. If this is set to
<code>'mc'</code> or <code>'par'</code> then <code>nmf</code> tries to
perform the runs using multiple cores with package
<code>link[doParallel]{doParallel}</code> &ndash; which therefore
needs to be installed.
</p>
<p>If equal to an integer, then <code>nmf</code> tries to perform
the computation on the specified number of processors.
When passing options as a string the number is appended
to the option's character e.g. <code>'p4'</code> for asking for
4 processors.
</p>
<p>If <code>FALSE</code>, then the computation is performed
sequentially using the base function
<code><a href="../../base/html/lapply.html">sapply</a></code>.
</p>
<p>Unlike option 'P' (capital 'P'), if the computation
cannot be performed in parallel, then it will still be
carried on sequentially.
</p>
<p><strong>IMPORTANT NOTE FOR MAC OS X USERS:</strong> The parallel
computation is based on the <code>doMC</code> and
<code>multicore</code> packages, so the same care should be
taken as stated in the vignette of <code>doMC</code>:
<em>&ldquo;it is not safe to use doMC from R.app on
Mac OS X. Instead, you should use doMC from a terminal
session, starting R from the command line.&rdquo;</em> </p>
</dd>
<dt>parallel.required - P</dt><dd><p> Same as <code>p</code>, but an
error is thrown if the computation cannot be performed in
parallel or with the specified number of processors.</p>
</dd>
<dt>shared.memory - m</dt><dd><p> toggle usage of shared memory
(requires the package <em>synchronicity</em>). Default is as
defined by <code>nmf.getOption('shared.memory')</code>.</p>
</dd>
<dt>restore.seed - r</dt><dd><p> deprecated option since version
0.5.99. Will throw a warning if used.</p>
</dd>
<dt>simplifyCB - S</dt><dd><p> toggle simplification of the
callback results. Default is <code>TRUE</code></p>
</dd>
<dt>track - t</dt><dd><p> enables error tracking (default:
FALSE). If <code>TRUE</code>, the returned object's slot
<code>residuals</code> contains the trajectory of the objective
values, which can be retrieved via <code>residuals(res,
  track=TRUE)</code> This tracking functionality is available for
all built-in algorithms. </p>
</dd>
<dt>verbose - v</dt><dd><p> Toggle verbosity (default:
<code>FALSE</code>). If <code>TRUE</code>, messages about the
configuration and the state of the current run(s) are
displayed. The level of verbosity may be specified with
an integer value, the greater the level the more messages
are displayed. Value <code>FALSE</code> means no messages are
displayed, while value <code>TRUE</code> is equivalent to
verbosity level 1. </p>
</dd>
</dl>
</td></tr>
<tr valign="top"><td><code>.pbackend</code></td>
<td>
<p>specification of the
<code><a href="../../foreach/html/foreach.html">foreach</a></code> parallel backend to register and/or
use when running in parallel mode. See options <code>p</code>
and <code>P</code> in argument <code>.options</code> for how to
enable this mode. Note that any backend that is
internally registered is cleaned-up on exit, so that the
calling foreach environment should not be affected by a
call to <code>nmf</code> &ndash; except when <code>.pbackend=NULL</code>.
</p>
<p>Currently it accepts the following values: </p>

<dl>
<dt>&lsquo;par&rsquo;</dt><dd><p> use the backend(s) defined by the
package <code><a href="../../doParallel/html/doParallel-package.html">doParallel</a></code>;</p>
</dd> <dt>a numeric
value</dt><dd><p> use the specified number of cores with
<code>doParallel</code> backend;</p>
</dd> <dt>&lsquo;seq&rsquo;</dt><dd><p> use the
foreach sequential backend <code>doSEQ</code>;</p>
</dd>
<dt><code>NULL</code></dt><dd><p> use currently registered backend;</p>
</dd>
<dt><code>NA</code></dt><dd><p> do not compute using a foreach loop &ndash;
and therefore not in parallel &ndash; but rather use a call to
standard <code><a href="../../base/html/lapply.html">sapply</a></code>. This is useful for when
developing/debugging NMF algorithms, as foreach loop
handling may sometime get in the way.
</p>
<p>Note that this is equivalent to using
<code>.options='-p'</code> or <code>.options='p0'</code>, but takes
precedence over any option specified in <code>.options</code>:
e.g. <code>nmf(..., .options='P10', .pbackend=NA)</code>
performs all runs sequentially using <code>sapply</code>. Use
<code>nmf.options(pbackend=NA)</code> to completely disable
foreach/parallel computations for all subsequent
<code>nmf</code> calls.</p>
</dd>
<dt>&lsquo;mc&rsquo;</dt><dd><p> identical to &lsquo;par&rsquo; and defined
to ensure backward compatibility.</p>
</dd> </dl>
</td></tr>
<tr valign="top"><td><code>.callback</code></td>
<td>
<p>Used when option <code>keep.all=FALSE</code>
(default).  It allows to pass a callback function that is
called after each run when performing multiple runs (i.e.
with <code>nrun&gt;1</code>). This is useful for example if one is
also interested in saving summary measures or process the
result of each NMF fit before it gets discarded. After
each run, the callback function is called with two
arguments, the <code><a href="NMFfit-class.html">NMFfit</a></code> object that as
just been fitted and the run number: <code>.callback(res,
  i)</code>. For convenience, a function that takes only one
argument or has signature <code>(x, ...)</code> can still be
passed in <code>.callback</code>. It is wrapped internally into
a dummy function with two arguments, only the first of
which is passed to the actual callback function (see
example with <code>summary</code>).
</p>
<p>The call is wrapped into a tryCatch so that callback
errors do not stop the whole computation (see below).
</p>
<p>The results of the different calls to the callback
function are stored in a miscellaneous slot accessible
using the method <code>$</code> for <code>NMFfit</code> objects:
<code>res$.callback</code>. By default <code>nmf</code> tries to
simplify the list of callback result using <code>sapply</code>,
unless option <code>'simplifyCB'</code> is <code>FASE</code>.
</p>
<p>If no error occurs <code>res$.callback</code> contains the list
of values that resulted from the calling the callback
function &ndash;, ordered as the fits. If any error occurs in
one of the callback calls, then the whole computation is
<strong>not</strong> stopped, but the error message is stored in
<code>res$.callback</code>, in place of the result.
</p>
<p>See the examples for sample code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>nmf</code> function has multiple methods that compose
a very flexible interface allowing to: </p>
 <ul>
<li>
<p>combine NMF algorithms with seeding methods and/or
stopping/convergence criterion at runtime;
</p>
</li>
<li><p> perform multiple NMF runs, which are computed in
parallel whenever the host machine allows it;
</p>
</li>
<li><p> run multiple algorithms with a common set of
parameters, ensuring a consistent environment (notably
the RNG settings). </p>
</li></ul>

<p>The workhorse method is
<code>nmf,matrix,numeric,NMFStrategy</code>, which is
eventually called by all other methods. The other methods
provides convenient ways of specifying the NMF
algorithm(s), the factorization rank, or the seed to be
used. Some allow to directly run NMF algorithms on
different types of objects, such as <code>data.frame</code> or
<code><a href="../../Biobase/html/ExpressionSet.html">ExpressionSet</a></code> objects.
</p>


<h3>Value</h3>

<p>The returned value depends on the run mode:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>Single run:</code></td>
<td>
<p>An object of class
<code><a href="NMFfit-class.html">NMFfit</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>Multiple runs, single method:</code></td>
<td>
<p>When <code>nrun &gt; 1</code>
and <code>method</code> is not <code>list</code>, this method returns
an object of class <code><a href="NMFfitX-class.html">NMFfitX</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>Multiple runs, multiple methods:</code></td>
<td>
<p>When <code>nrun &gt;
  1</code> and <code>method</code> is a <code>list</code>, this method
returns an object of class <code><a href="NMFList-class.html">NMFList</a></code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>nmf</dt><dd><p><code>signature(x = "data.frame", rank =
  "ANY", method = "ANY")</code>: Fits an NMF model on a
<code>data.frame</code>.
</p>
<p>The target <code>data.frame</code> is coerced into a matrix
with <code><a href="../../base/html/matrix.html">as.matrix</a></code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "NULL")</code>: Fits an NMF model using an
appropriate algorithm when <code>method</code> is not supplied.
</p>
<p>This method tries to select an appropriate algorithm
amongst the NMF algorithms stored in the internal
algorithm registry, which contains the type of NMF models
each algorithm can fit. This is possible when the type of
NMF model to fit is available from argument <code>seed</code>,
i.e. if it is an NMF model itself. Otherwise the
algorithm to use is obtained from
<code>nmf.getOption('default.algorithm')</code>.
</p>
<p>This method is provided for internal usage, when called
from other <code>nmf</code> methods with argument <code>method</code>
missing in the top call (e.g.
<code>nmf,matrix,numeric,missing</code>). </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "list")</code>: Fits multiple NMF models on
a common matrix using a list of algorithms.
</p>
<p>The models are fitted sequentially with <code>nmf</code> using
the same options and parameters for all algorithms. In
particular, irrespective of the way the computation is
seeded, this method ensures that all fits are performed
using the same initial RNG settings.
</p>
<p>This method returns an object of class
<code><a href="NMFList-class.html">NMFList</a></code>, that is essentially a list
containing each fit. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "character")</code>: Fits an NMF model on
<code>x</code> using an algorithm registered with access key
<code>method</code>.
</p>
<p>Argument <code>method</code> is partially match against the
access keys of all registered algorithms (case
insensitive). Available algorithms are listed in section
<em>Algorithms</em> below or the introduction vignette. A
vector of their names may be retrieved via
<code>nmfAlgorithm()</code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "function")</code>: Fits an NMF model on
<code>x</code> using a custom algorithm defined the function
<code>method</code>.
</p>
<p>The supplied function must have signature
<code>(x=matrix, start=NMF, ...)</code> and return an object
that inherits from class <code><a href="NMF-class.html">NMF</a></code>. It
will be called internally by the workhorse <code>nmf</code>
method, with an NMF model to be used as a starting point
passed in its argument <code>start</code>.
</p>
<p>Extra arguments in <code>...</code> are passed to <code>method</code>
from the top <code>nmf</code> call. Extra arguments that have
no default value in the definition of the function
<code>method</code> are required to run the algorithm (e.g. see
argument <code>alpha</code> of <code>myfun</code> in the examples).
</p>
<p>If the algorithm requires a specific type of NMF model,
this can be specified in argument <code>model</code> that is
handled as in the workhorse <code>nmf</code> method (see
description for this argument). </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank = "NMF",
  method = "ANY")</code>: Fits an NMF model using the NMF model
<code>rank</code> to seed the computation, i.e. as a starting
point.
</p>
<p>This method is provided for convenience as a shortcut for
<code>nmf(x, nbasis(object), method, seed=object, ...)</code>
It discards any value passed in argument <code>seed</code> and
uses the NMF model passed in <code>rank</code> instead. It
throws a warning if argument <code>seed</code> not missing.
</p>
<p>If <code>method</code> is missing, this method will call the
method <code>nmf,matrix,numeric,NULL</code>, which will infer
an algorithm suitable for fitting an NMF model of the
class of <code>rank</code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank = "NULL",
  method = "ANY")</code>: Fits an NMF model using the NMF model
supplied in <code>seed</code>, to seed the computation, i.e. as
a starting point.
</p>
<p>This method is provided for completeness and is
equivalent to <code>nmf(x, seed, method, ...)</code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "missing", method = "ANY")</code>: Method defined to ensure the
correct dispatch to workhorse methods in case of argument
<code>rank</code> is missing. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "numeric", method = "missing")</code>: Method defined to ensure
the correct dispatch to workhorse methods in case of
argument <code>method</code> is missing. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank = "matrix",
  method = "ANY")</code>: Fits an NMF model partially seeding the
computation with a given matrix passed in <code>rank</code>.
</p>
<p>The matrix <code>rank</code> is used either as initial value
for the basis or mixture coefficient matrix, depending on
its dimension.
</p>
<p>Currently, such partial NMF model is directly used as a
seed, meaning that the remaining part is left
uninitialised, which is not accepted by all NMF
algorithm. This should change in the future, where the
missing part of the model will be drawn from some random
distribution.
</p>
<p>Amongst built-in algorithms, only &lsquo;snmf/l&rsquo; and
&lsquo;snmf/r&rsquo; support partial seeds, with only the
coefficient or basis matrix initialised respectively. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "matrix", rank =
  "data.frame", method = "ANY")</code>: Shortcut for <code>nmf(x,
  as.matrix(rank), method, ...)</code>. </p>
</dd>
<dt>nmf</dt><dd><p><code>signature(x = "formula", rank = "ANY",
  method = "ANY")</code>: This method implements the interface
for fitting formula-based NMF models. See
<code><a href="nmfModel.html">nmfModel</a></code>.
</p>
<p>Argument <code>rank</code> target matrix or formula
environment. If not missing, <code>model</code> must be a
<code>list</code>, a <code>data.frame</code> or an <code>environment</code>
in which formula variables are searched for. </p>
</dd>
</dl>



<h3>Optimized C++ vs. plain R</h3>

<p>Lee and Seung's multiplicative updates are used by
several NMF algorithms. To improve speed and memory
usage, a C++ implementation of the specific matrix
products is used whenever possible. It directly computes
the updates for each entry in the updated matrix, instead
of using multiple standard matrix multiplication.
</p>
<p>The algorithms that benefit from this optimization are:
'brunet', 'lee', 'nsNMF' and 'offset'. 
However there still exists plain R versions for these
methods, which implement the updates as standard matrix
products. These are accessible by adding the prefix '.R#'
to their name: '.R#brunet', '.R#lee', '.R#nsNMF' and
'.R#offset'.
</p>


<h3>Algorithms</h3>

<p>All algorithms are accessible by their respective access
key as listed below. The following algorithms are
available: </p>

<dl>
<dt>&lsquo;brunet&rsquo;</dt><dd><p> Standard NMF, based on the
Kullback-Leibler divergence, from <cite>Brunet et al. (2004)</cite>. It
uses simple multiplicative updates from <cite>Lee et al. (2001)</cite>,
enhanced to avoid numerical underflow.
</p>
<p>Default stopping criterion: invariance of the
connectivity matrix (see
<code><a href="stop-NMF.html">nmf.stop.connectivity</a></code>). </p>
</dd>
<dt>&lsquo;lee&rsquo;</dt><dd><p> Standard NMF based on the Euclidean
distance from <cite>Lee et al. (2001)</cite>. It uses simple
multiplicative updates.
</p>
<p>Default stopping criterion: invariance of the
connectivity matrix (see
<code><a href="stop-NMF.html">nmf.stop.connectivity</a></code>). </p>
</dd>
<dt>ls-nmf</dt><dd><p> Least-Square NMF from <cite>Wang et al. (2006)</cite>. It
uses modified versions of Lee and Seung's multiplicative
updates for the Euclidean distance, which incorporates
weights on each entry of the target matrix, e.g. to
reflect measurement uncertainty.
</p>
<p>Default stopping criterion: stationarity of the objective
function (see <code><a href="stop-NMF.html">nmf.stop.stationary</a></code>). </p>
</dd>
<dt>&lsquo;nsNMF&rsquo;</dt><dd><p> Nonsmooth NMF from
<cite>Pascual-Montano et al. (2006)</cite>. It uses a modified version of
Lee and Seung's multiplicative updates for the
Kullback-Leibler divergence <cite>Lee et al. (2001)</cite>, to fit a
extension of the standard NMF model, that includes an
intermediate smoothing matrix, meant meant to produce
sparser factors.
</p>
<p>Default stopping criterion: invariance of the
connectivity matrix (see
<code><a href="stop-NMF.html">nmf.stop.connectivity</a></code>). </p>
</dd>
<dt>&lsquo;offset&rsquo;</dt><dd><p> NMF with offset from
<cite>Badea (2008)</cite>. It uses a modified version of Lee and
Seung's multiplicative updates for Euclidean distance
<cite>Lee et al. (2001)</cite>, to fit an NMF model that includes an
intercept, meant to capture a common baseline and shared
patterns, in order to produce cleaner basis components.
</p>
<p>Default stopping criterion: invariance of the
connectivity matrix (see
<code><a href="stop-NMF.html">nmf.stop.connectivity</a></code>). </p>
</dd>
<dt>&lsquo;pe-nmf&rsquo;</dt><dd><p> Pattern-Expression NMF from
<em>Zhang2008</em>. It uses multiplicative updates to
minimize an objective function based on the Euclidean
distance, that is regularized for effective expression of
patterns with basis vectors.
</p>
<p>Default stopping criterion: stationarity of the objective
function (see <code><a href="stop-NMF.html">nmf.stop.stationary</a></code>). </p>
</dd>
<dt>&lsquo;snmf/r&rsquo;, &lsquo;snmf/l&rsquo;</dt><dd><p> Alternating
Least Square (ALS) approach from <cite>Kim et al. (2007)</cite>. It
applies the nonnegative least-squares algorithm from
<cite>Van Benthem et al. (2004)</cite> (i.e. fast combinatorial
nonnegative least-squares for multiple right-hand), to
estimate the basis and coefficient matrices alternatively
(see <code><a href="fcnnls.html">fcnnls</a></code>). It minimises an
Euclidean-based objective function, that is regularized
to favour sparse basis matrices (for &lsquo;snmf/l&rsquo;) or
sparse coefficient matrices (for &lsquo;snmf/r&rsquo;).
</p>
<p>Stopping criterion: built-in within the internal
workhorse function <code>nmf_snmf</code>, based on the KKT
optimality conditions. </p>
</dd>
</dl>



<h3>Seeding methods</h3>

<p>The purpose of seeding methods is to compute initial
values for the factor matrices in a given NMF model. This
initial guess will be used as a starting point by the
chosen NMF algorithm.
</p>
<p>The seeding method to use in combination with the
algorithm can be passed to interface <code>nmf</code> through
argument <code>seed</code>. The seeding seeding methods
available in registry are listed by the function
<code><a href="nmfSeed.html">nmfSeed</a></code> (see list therein).
</p>
<p>Detailed examples of how to specify the seeding method
and its parameters can be found in the <em>Examples</em>
section of this man page and in the package's vignette.
</p>


<h3>References</h3>

<p>Brunet J, Tamayo P, Golub TR and Mesirov JP (2004).
&quot;Metagenes and molecular pattern discovery using matrix
factorization.&quot; _Proceedings of the National Academy of
Sciences of the United States of America_, *101*(12), pp.
4164-9. ISSN 0027-8424, &lt;URL:
http://dx.doi.org/10.1073/pnas.0308531101&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/15016911&gt;.
</p>
<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization\#0&gt;.
</p>
<p>Wang G, Kossenkov AV and Ochs MF (2006). &quot;LS-NMF: a
modified non-negative matrix factorization algorithm
utilizing uncertainty estimates.&quot; _BMC bioinformatics_,
*7*, pp. 175. ISSN 1471-2105, &lt;URL:
http://dx.doi.org/10.1186/1471-2105-7-175&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/16569230&gt;.
</p>
<p>Pascual-Montano A, Carazo JM, Kochi K, Lehmann D and
Pascual-marqui RD (2006). &quot;Nonsmooth nonnegative matrix
factorization (nsNMF).&quot; _IEEE Trans. Pattern Anal. Mach.
Intell_, *28*, pp. 403-415.
</p>
<p>Badea L (2008). &quot;Extracting gene expression profiles
common to colon and pancreatic adenocarcinoma using
simultaneous nonnegative matrix factorization.&quot; _Pacific
Symposium on Biocomputing. Pacific Symposium on
Biocomputing_, *290*, pp. 267-78. ISSN 1793-5091, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/18229692&gt;.
</p>
<p>Kim H and Park H (2007). &quot;Sparse non-negative matrix
factorizations via alternating non-negativity-constrained
least squares for microarray data analysis.&quot;
_Bioinformatics (Oxford, England)_, *23*(12), pp.
1495-502. ISSN 1460-2059, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btm134&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/17483501&gt;.
</p>
<p>Van Benthem M and Keenan MR (2004). &quot;Fast algorithm for
the solution of large-scale non-negativity-constrained
least squares problems.&quot; _Journal of Chemometrics_,
*18*(10), pp. 441-450. ISSN 0886-9383, &lt;URL:
http://dx.doi.org/10.1002/cem.889&gt;, &lt;URL:
http://doi.wiley.com/10.1002/cem.889&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="nmfAlgorithm.html">nmfAlgorithm</a></code>
</p>


<h3>Examples</h3>

<pre>


# Only basic calls are presented in this manpage.
# Many more examples are provided in the demo file nmf.R
## Not run: 
demo('nmf')

## End(Not run)

# random data
x &lt;- rmatrix(20,10)

# run default algorithm with rank 2
res &lt;- nmf(x, 2)

# specify the algorithm
res &lt;- nmf(x, 2, 'lee')

# get verbose message on what is going on
res &lt;- nmf(x, 2, .options='v')
## Not run: 
# more messages
res &lt;- nmf(x, 2, .options='v2')
# even more
res &lt;- nmf(x, 2, .options='v3')
# and so on ...

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>NMF</em> version 0.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
