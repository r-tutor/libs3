<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Generating Random NMF Models</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for rnmf {NMF}"><tr><td>rnmf {NMF}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Generating Random NMF Models</h2>

<h3>Description</h3>

<p>Generates NMF models with random values drawn from a
uniform distribution. It returns an NMF model with basis
and mixture coefficient matrices filled with random
values. The main purpose of the function <code>rnmf</code> is
to provide a common interface to generate random seeds
used by the <code><a href="nmf.html">nmf</a></code> function.
</p>


<h3>Usage</h3>

<pre>
  rnmf(x, target, ...)

  ## S4 method for signature 'NMF,numeric'
rnmf(x, target, ncol = NULL,
    keep.names = TRUE, dist = runif)

  ## S4 method for signature 'ANY,matrix'
rnmf(x, target, ...,
    dist = list(max = max(max(target, na.rm = TRUE), 1)),
    use.dimnames = TRUE)

  ## S4 method for signature 'numeric,missing'
rnmf(x, target, ..., W, H,
    dist = runif)

  ## S4 method for signature 'missing,missing'
rnmf(x, target, ..., W, H)

  ## S4 method for signature 'numeric,numeric'
rnmf(x, target, ncol = NULL,
    ..., dist = runif)

  ## S4 method for signature 'formula,ANY'
rnmf(x, target, ...,
    dist = runif)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>an object that determines the rank, dimension
and/or class of the generated NMF model, e.g. a numeric
value or an object that inherits from class
<code><a href="NMF-class.html">NMF</a></code>. See the description of the
specific methods for more details on the supported
types.</p>
</td></tr>
<tr valign="top"><td><code>target</code></td>
<td>
<p>optional specification of target
dimensions. See section <em>Methods</em> for how this
parameter is used by the different methods.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>extra arguments to allow extensions and passed
to the next method eventually down to
<code><a href="nmfModel.html">nmfModel</a></code>, where they are used to initialise
slots that are specific to the instantiating NMF model.</p>
</td></tr>
<tr valign="top"><td><code>ncol</code></td>
<td>
<p>single numeric value that specifies the
number of columns of the coefficient matrix. Only used
when <code>target</code> is a single numeric value.</p>
</td></tr>
<tr valign="top"><td><code>keep.names</code></td>
<td>
<p>a logical that indicates if the
dimension names of the original NMF object <code>x</code>
should be conserved (<code>TRUE</code>) or discarded
(<code>FALSE</code>).</p>
</td></tr>
<tr valign="top"><td><code>dist</code></td>
<td>
<p>specification of the random distribution to
use to draw the entries of the basis and coefficient
matrices. It may be specified as: </p>

<ul>
<li><p> a <code>function</code> which must be a distribution
function such as e.g. <code><a href="../../stats/html/Uniform.html">runif</a></code> that is used to
draw the entries of both the basis and coefficient
matrices. It is passed in the <code>dist</code> argument of
<code><a href="rmatrix.html">rmatrix</a></code>.
</p>
</li>
<li><p> a <code>list</code> of arguments that are passed
internally to <code><a href="rmatrix.html">rmatrix</a></code>, via
<code>do.call('rmatrix', dist)</code>.
</p>
</li>
<li><p> a <code>character</code> string that is partially matched
to &lsquo;basis&rsquo; or &lsquo;coef&rsquo;, that specifies which
matrix in should be drawn randomly, the other remaining
as in <code>x</code> &ndash; unchanged.
</p>
</li>
<li><p> a <code>list</code> with elements &lsquo;basis&rsquo; and/or
&lsquo;coef&rsquo;, which specify the <code>dist</code> argument
separately for the basis and coefficient matrix
respectively.
</p>
<p>These elements may be either a distribution function, or
a list of arguments that are passed internally to
<code><a href="rmatrix.html">rmatrix</a></code>, via <code>do.call('rmatrix',
  dist$basis)</code> or <code>do.call('rmatrix', dist$coef)</code>. </p>
</li></ul>
</td></tr>
<tr valign="top"><td><code>use.dimnames</code></td>
<td>
<p>a logical that indicates whether the
dimnames of the target matrix should be set on the
returned NMF model.</p>
</td></tr>
<tr valign="top"><td><code>W</code></td>
<td>
<p>value for the basis matrix. <code>data.frame</code>
objects are converted into matrices with
<code><a href="../../base/html/matrix.html">as.matrix</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>H</code></td>
<td>
<p>value for the mixture coefficient matrix
<code>data.frame</code> objects are converted into matrices
with <code><a href="../../base/html/matrix.html">as.matrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If necessary, extensions of the standard NMF model or
custom models must define a method
&quot;rnmf,&lt;NMF.MODEL.CLASS&gt;,numeric&quot; for initialising their
specific slots other than the basis and mixture
coefficient matrices. In order to benefit from the
complete built-in interface, the overloading methods
should call the generic version using function
<code><a href="../../methods/html/NextMethod.html">callNextMethod</a></code>, prior to set the values of
the specific slots. See for example the method
<code><a href="rnmf.html">rnmf</a></code>
defined for <code><a href="NMFOffset-class.html">NMFOffset</a></code> models:
<code>showMethods(rnmf, class='NMFOffset',
  include=TRUE))</code>.
</p>
<p>For convenience, shortcut methods for working on
<code>data.frame</code> objects directly are implemented.
However, note that conversion of a <code>data.frame</code> into
a <code>matrix</code> object may take some non-negligible time,
for large datasets. If using this method or other
NMF-related methods several times, consider converting
your data <code>data.frame</code> object into a matrix once for
good, when first loaded.
</p>


<h3>Value</h3>

<p>An NMF model, i.e. an object that inherits from class
<code><a href="NMF-class.html">NMF</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>rnmf</dt><dd><p><code>signature(x = "NMFOffset", target =
  "numeric")</code>: Generates a random NMF model with offset,
from class <code>NMFOffset</code>.
</p>
<p>The offset values are drawn from a uniform distribution
between 0 and the maximum entry of the basis and
coefficient matrices, which are drawn by the next
suitable <code><a href="rnmf.html">rnmf</a></code> method, which is the
workhorse method <code>rnmf,NMF,numeric</code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "NMF", target =
  "numeric")</code>: Generates a random NMF model of the same
class and rank as another NMF model.
</p>
<p>This is the workhorse method that is eventually called by
all other methods. It generates an NMF model of the same
class and rank as <code>x</code>, compatible with the
dimensions specified in <code>target</code>, that can be a
single or 2-length numeric vector, to specify a square or
rectangular target matrix respectively.
</p>
<p>The second dimension can also be passed via argument
<code>ncol</code>, so that calling <code>rnmf(x, 20, 10, ...)</code>
is equivalent to <code>rnmf(x, c(20, 10), ...)</code>, but
easier to write.
</p>
<p>The entries are uniformly drawn between <code>0</code> and
<code>max</code> (optionally specified in <code>...</code>) that
defaults to 1.
</p>
<p>By default the dimnames of <code>x</code> are set on the
returned NMF model. This behaviour is disabled with
argument <code>keep.names=FALSE</code>. See
<code><a href="nmfModel.html">nmfModel</a></code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "ANY", target =
  "matrix")</code>: Generates a random NMF model compatible and
consistent with a target matrix.
</p>
<p>The entries are uniformly drawn between <code>0</code> and
<code>max(target)</code>. It is more or less a shortcut for:
<span class="samp"> rnmf(x, dim(target), max=max(target), ...)</span>
</p>
<p>It returns an NMF model of the same class as <code>x</code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "ANY", target =
  "data.frame")</code>: Shortcut for <code>rnmf(x,
  as.matrix(target))</code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "NMF", target =
  "missing")</code>: Generates a random NMF model of the same
dimension as another NMF model.
</p>
<p>It is a shortcut for <code>rnmf(x, nrow(x), ncol(x),
  ...)</code>, which returns a random NMF model of the same class
and dimensions as <code>x</code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "numeric", target =
  "missing")</code>: Generates a random NMF model of a given
rank, with known basis and/or coefficient matrices.
</p>
<p>This methods allow to easily generate partially random
NMF model, where one or both factors are known. Although
the later case might seems strange, it makes sense for
NMF models that have fit extra data, other than the basis
and coefficient matrices, that are drawn by an
<code>rnmf</code> method defined for their own class, which
should internally call <code>rnmf,NMF,numeric</code> and let it
draw the basis and coefficient matrices. (e.g. see
<code><a href="NMFOffset-class.html">NMFOffset</a></code> and
<code><a href="rnmf.html">rnmf,NMFOffset,numeric-method</a></code>).
</p>
<p>Depending on whether arguments <code>W</code> and/or <code>H</code>
are missing, this method interprets <code>x</code> differently:
</p>

<ul>
<li> <p><code>W</code> provided, <code>H</code> missing: <code>x</code> is
taken as the number of columns that must be drawn to
build a random coefficient matrix (i.e. the number of
columns in the target matrix).
</p>
</li>
<li> <p><code>W</code> is missing, <code>H</code> is provided: <code>x</code>
is taken as the number of rows that must be drawn to
build a random basis matrix (i.e. the number of rows in
the target matrix).
</p>
</li>
<li><p> both <code>W</code> and <code>H</code> are provided: <code>x</code>
is taken as the target rank of the model to generate.
</p>
</li>
<li><p> Having both <code>W</code> and <code>H</code> missing produces
an error, as the dimension of the model cannot be
determined in this case. </p>
</li></ul>

<p>The matrices <code>W</code> and <code>H</code> are reduced if
necessary and possible to be consistent with this value
of the rank, by the internal call to
<code><a href="nmfModel.html">nmfModel</a></code>.
</p>
<p>All arguments in <code>...</code> are passed to the function
<code><a href="nmfModel.html">nmfModel</a></code> which is used to build an initial
NMF model, that is in turn passed to
<code>rnmf,NMF,numeric</code> with <code>dist=list(coef=dist)</code>
or <code>dist=list(basis=dist)</code> when suitable. The type
of NMF model to generate can therefore be specified in
argument <code>model</code> (see <code><a href="nmfModel.html">nmfModel</a></code> for
other possible arguments).
</p>
<p>The returned NMF model, has a basis matrix equal to
<code>W</code> (if not missing) and a coefficient matrix equal
to <code>H</code> (if not missing), or drawn according to the
specification provided in argument <code>dist</code> (see
method <code>rnmf,NMF,numeric</code> for details on the
supported values for <code>dist</code>). </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "missing", target =
  "missing")</code>: Generates a random NMF model with known
basis and coefficient matrices.
</p>
<p>This method is a shortcut for calling
<code>rnmf,numeric,missing</code> with a suitable value for
<code>x</code> (the rank), when both factors are known:
codernmf(min(ncol(W), nrow(H)), ..., W=W, H=H).
</p>
<p>Arguments <code>W</code> and <code>H</code> are required. Note that
calling this method only makes sense for NMF models that
contains data to fit other than the basis and coefficient
matrices, e.g. <code><a href="NMFOffset-class.html">NMFOffset</a></code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "numeric", target =
  "numeric")</code>: Generates a random standard NMF model of
given dimensions.
</p>
<p>This is a shortcut for <code>rnmf(nmfModel(x, target,
  ncol, ...)), dist=dist)</code>. It generates a standard NMF
model compatible with the dimensions passed in
<code>target</code>, that can be a single or 2-length numeric
vector, to specify a square or rectangular target matrix
respectively. See <code><a href="nmfModel.html">nmfModel</a></code>. </p>
</dd>
<dt>rnmf</dt><dd><p><code>signature(x = "formula", target =
  "ANY")</code>: Generate a random formula-based NMF model, using
the method <code><a href="nmfModel.html">nmfModel,formula,ANY-method</a></code>. </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="rmatrix.html">rmatrix</a></code>
</p>
<p>Other NMF-interface: <code><a href="basis-coef-methods.html">basis</a></code>,
<code><a href="basis-coef-methods.html">.basis</a></code>, <code><a href="basis-coef-methods.html">.basis&lt;-</a></code>,
<code><a href="basis-coef-methods.html">basis&lt;-</a></code>, <code><a href="basis-coef-methods.html">coef</a></code>,
<code><a href="basis-coef-methods.html">.coef</a></code>, <code><a href="basis-coef-methods.html">.coef&lt;-</a></code>,
<code><a href="basis-coef-methods.html">coef&lt;-</a></code>, <code><a href="basis-coef-methods.html">coefficients</a></code>,
<code><a href="NMF-class.html">.DollarNames,NMF-method</a></code>,
<code><a href="basis-coef-methods.html">loadings,NMF-method</a></code>, <code><a href="NMF-class.html">misc</a></code>,
<code><a href="NMF-class.html">NMF-class</a></code>, <code><a href="NMF-class.html">$&lt;-,NMF-method</a></code>,
<code><a href="NMF-class.html">$,NMF-method</a></code>, <code><a href="nmfModel.html">nmfModel</a></code>,
<code><a href="nmfModel.html">nmfModels</a></code>, <code><a href="basis-coef-methods.html">scoef</a></code>
</p>


<h3>Examples</h3>

<pre>


#----------
# rnmf,NMFOffset,numeric-method
#----------
# random NMF model with offset
x &lt;- rnmf(2, 3, model='NMFOffset')
x
offset(x)
# from a matrix
x &lt;- rnmf(2, rmatrix(5,3, max=10), model='NMFOffset')
offset(x)

#----------
# rnmf,NMF,numeric-method
#----------
## random NMF of same class and rank as another model

x &lt;- nmfModel(3, 10, 5)
x
rnmf(x, 20) # square
rnmf(x, 20, 13)
rnmf(x, c(20, 13))

# using another distribution
rnmf(x, 20, dist=rnorm)

# other than standard model
y &lt;- rnmf(3, 50, 10, model='NMFns')
y



#----------
# rnmf,ANY,matrix-method
#----------
# random NMF compatible with a target matrix
x &lt;- nmfModel(3, 10, 5)
y &lt;- rmatrix(20, 13)
rnmf(x, y) # rank of x
rnmf(2, y) # rank 2

#----------
# rnmf,NMF,missing-method
#----------
## random NMF from another model

a &lt;- nmfModel(3, 100, 20)
b &lt;- rnmf(a)


#----------
# rnmf,numeric,missing-method
#----------
# random NMF model with known basis matrix
x &lt;- rnmf(5, W=matrix(1:18, 6)) # 6 x 5 model with rank=3
basis(x) # fixed
coef(x) # random

# random NMF model with known coefficient matrix
x &lt;- rnmf(5, H=matrix(1:18, 3)) # 5 x 6 model with rank=3
basis(x) # random
coef(x) # fixed

# random model other than standard NMF
x &lt;- rnmf(5, H=matrix(1:18, 3), model='NMFOffset')
basis(x) # random
coef(x) # fixed
offset(x) # random

#----------
# rnmf,missing,missing-method
#----------
# random model other than standard NMF
x &lt;- rnmf(W=matrix(1:18, 6), H=matrix(21:38, 3), model='NMFOffset')
basis(x) # fixed
coef(x) # fixed
offset(x) # random

#----------
# rnmf,numeric,numeric-method
#----------
## random standard NMF of given dimensions

# generate a random NMF model with rank 3 that fits a 100x20 matrix
rnmf(3, 100, 20)

# generate a random NMF model with rank 3 that fits a 100x100 matrix
rnmf(3, 100)

</pre>

<hr /><div style="text-align: center;">[Package <em>NMF</em> version 0.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
