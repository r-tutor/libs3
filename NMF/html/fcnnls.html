<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Fast Combinatorial Nonnegative Least-Square</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for fcnnls {NMF}"><tr><td>fcnnls {NMF}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Fast Combinatorial Nonnegative Least-Square</h2>

<h3>Description</h3>

<p>This function solves the following nonnegative least
square linear problem using normal equations and the fast
combinatorial strategy from <cite>Van Benthem et al.
(2004)</cite>:
</p>
<p style="text-align: center;"><i>min ||Y - X K||_F, s.t. K&gt;=0</i></p>

<p>where <i>Y</i> and <i>X</i> are two real matrices of
dimension <i>n x p</i> and <i>n
  x r</i> respectively, and <i>|.|_F</i> is the
Frobenius norm.
</p>
<p>The algorithm is very fast compared to other approaches,
as it is optimised for handling multiple right-hand
sides.
</p>


<h3>Usage</h3>

<pre>
  fcnnls(x, y, ...)

  ## S4 method for signature 'matrix,matrix'
fcnnls(x, y, verbose = FALSE,
    pseudo = TRUE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>...</code></td>
<td>
<p>extra arguments passed to the internal
function <code>.fcnnls</code>. Currently not used.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>toggle verbosity (default is
<code>FALSE</code>).</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>the coefficient matrix</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>the target matrix to be approximated by <i>X
  K</i>.</p>
</td></tr>
<tr valign="top"><td><code>pseudo</code></td>
<td>
<p>By default (<code>pseudo=FALSE</code>) the
algorithm uses Gaussian elimination to solve the
successive internal linear problems, using the
<code><a href="../../Matrix/html/solve-methods.html">solve</a></code> function.  If <code>pseudo=TRUE</code> the
algorithm uses Moore-Penrose generalized
<code><a href="../../corpcor/html/pseudoinverse.html">pseudoinverse</a></code> from the
<code>corpcor</code> package instead of <a href="../../Matrix/html/solve-methods.html">solve</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within the <code>NMF</code> package, this algorithm is used
internally by the SNMF/R(L) algorithm from <cite>Kim et
al. (2007)</cite> to solve general Nonnegative Matrix
Factorization (NMF) problems, using alternating
nonnegative constrained least-squares. That is by
iteratively and alternatively estimate each matrix
factor.
</p>
<p>The algorithm is an active/passive set method, which
rearrange the right-hand side to reduce the number of
pseudo-inverse calculations. It uses the unconstrained
solution <i>K_u</i> obtained from the unconstrained least
squares problem, i.e. <i>min ||Y
  - X K||_F^2</i> , so as to determine the initial passive
sets.
</p>
<p>The function <code>fcnnls</code> is provided separately so that
it can be used to solve other types of nonnegative least
squares problem. For faster computation, when multiple
nonnegative least square fits are needed, it is
recommended to directly use the function
<code><a href="dot-fcnnls.html">.fcnnls</a></code>.
</p>
<p>The code of this function is a port from the original
MATLAB code provided by <cite>Kim et al. (2007)</cite>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p> the estimated optimal matrix <i>K</i>.</p>
</td></tr>
<tr valign="top"><td><code>fitted</code></td>
<td>
<p> the fitted matrix <i>X K</i>.</p>
</td></tr>
<tr valign="top"><td><code>residuals</code></td>
<td>
<p> the residual matrix <i>Y - X K</i>.</p>
</td></tr>
<tr valign="top"><td><code>deviance</code></td>
<td>
<p> the residual sum of squares between the
fitted matrix <i>X K</i> and the target matrix <i>Y</i>.
That is the sum of the square residuals.</p>
</td></tr> <tr valign="top"><td><code>passive</code></td>
<td>

<p>a <i>r x p</i> logical matrix containing the passive set,
that is the set of entries in <i>K</i> that are not null
(i.e. strictly positive).</p>
</td></tr> <tr valign="top"><td><code>pseudo</code></td>
<td>
<p> a logical that
is <code>TRUE</code> if the computation was performed using the
pseudoinverse. See argument <code>pseudo</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>fcnnls</dt><dd><p><code>signature(x = "matrix", y =
  "matrix")</code>: This method wraps a call to the internal
function <code>.fcnnls</code>, and formats the results in a
similar way as other lest-squares methods such as
<code><a href="../../stats/html/lm.html">lm</a></code>. </p>
</dd>
<dt>fcnnls</dt><dd><p><code>signature(x = "numeric", y =
  "matrix")</code>: Shortcut for <code>fcnnls(as.matrix(x), y,
  ...)</code>. </p>
</dd>
<dt>fcnnls</dt><dd><p><code>signature(x = "ANY", y = "numeric")</code>:
Shortcut for <code>fcnnls(x, as.matrix(y), ...)</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Original MATLAB code : Van Benthem and Keenan
</p>
<p>Adaption of MATLAB code for SNMF/R(L): H. Kim
</p>
<p>Adaptation to the NMF package framework: Renaud Gaujoux
</p>


<h3>References</h3>

<p>Original MATLAB code from Van Benthem and Keenan,
slightly modified by H. Kim:<br />
<a href="http://www.cc.gatech.edu/~hpark/software/fcnnls.m">http://www.cc.gatech.edu/~hpark/software/fcnnls.m</a>
</p>
<p>Van Benthem M and Keenan MR (2004). &quot;Fast algorithm for
the solution of large-scale non-negativity-constrained
least squares problems.&quot; _Journal of Chemometrics_,
*18*(10), pp. 441-450. ISSN 0886-9383, &lt;URL:
http://dx.doi.org/10.1002/cem.889&gt;, &lt;URL:
http://doi.wiley.com/10.1002/cem.889&gt;.
</p>
<p>Kim H and Park H (2007). &quot;Sparse non-negative matrix
factorizations via alternating non-negativity-constrained
least squares for microarray data analysis.&quot;
_Bioinformatics (Oxford, England)_, *23*(12), pp.
1495-502. ISSN 1460-2059, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btm134&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/17483501&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="nmf.html">nmf</a></code>
</p>


<h3>Examples</h3>

<pre>


## Define a random nonnegative matrix matrix
n &lt;- 200; p &lt;- 20; r &lt;- 3
V &lt;- rmatrix(n, p)

## Compute the optimal matrix K for a given X matrix
X &lt;- rmatrix(n, r)
res &lt;- fcnnls(X, V)

## Compute the same thing using the Moore-Penrose generalized pseudoinverse
res &lt;- fcnnls(X, V, pseudo=TRUE)

## It also works in the case of single vectors
y &lt;- runif(n)
res &lt;- fcnnls(X, y)
# or
res &lt;- fcnnls(X[,1], y)
</pre>

<hr /><div style="text-align: center;">[Package <em>NMF</em> version 0.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
