<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Residual Sum of Squares and Explained Variance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for rss {NMF}"><tr><td>rss {NMF}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Residual Sum of Squares and Explained Variance</h2>

<h3>Description</h3>

<p><code>rss</code> and <code>evar</code> are S4 generic functions that
respectively computes the Residual Sum of Squares (RSS)
and explained variance achieved by a model.
</p>
<p>The explained variance for a target <i>V</i> is computed
as: </p>
<p style="text-align: center;"><i>evar = 1 - RSS/sum v_{ij}^2</i></p>
<p>,
</p>


<h3>Usage</h3>

<pre>
  rss(object, ...)

  ## S4 method for signature 'matrix'
rss(object, target)

  evar(object, ...)

  ## S4 method for signature 'ANY'
evar(object, target, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p>an R object with a suitable
<code><a href="fitted.html">fitted</a></code>, <code>rss</code> or <code>evar</code> method.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>extra arguments to allow extension, e.g.
passed to <code>rss</code> in <code>evar</code> calls.</p>
</td></tr>
<tr valign="top"><td><code>target</code></td>
<td>
<p>target matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>where RSS is the residual sum of squares.
</p>
<p>The explained variance is usefull to compare the
performance of different models and their ability to
accurately reproduce the original target matrix. Note,
however, that a possible caveat is that some models
explicitly aim at minimizing the RSS (i.e. maximizing the
explained variance), while others do not.
</p>


<h3>Value</h3>

<p>a single numeric value
</p>


<h3>Methods</h3>


<dl>
<dt>evar</dt><dd><p><code>signature(object = "ANY")</code>: Default
method for <code>evar</code>.
</p>
<p>It requires a suitable <code>rss</code> method to be defined
for <code>object</code>, as it internally calls
<code>rss(object, target, ...)</code>. </p>
</dd>
<dt>rss</dt><dd><p><code>signature(object = "matrix")</code>: Computes
the RSS between a target matrix and its estimate
<code>object</code>, which must be a matrix of the same
dimensions as <code>target</code>.
</p>
<p>The RSS between a target matrix <i>V</i> and its estimate
<i>v</i> is computed as: </p>
<p style="text-align: center;"><i>RSS = &sum;_{i,j} (v_{ij} -
  V_{ij})^2</i></p>

<p>Internally, the computation is performed using an
optimised C++ implementation, that is light in memory
usage. </p>
</dd>
<dt>rss</dt><dd><p><code>signature(object = "ANY")</code>: Residual sum
of square between a given target matrix and a model that
has a suitable <code><a href="fitted.html">fitted</a></code> method. It is
equivalent to <code>rss(fitted(object), ...)</code>
</p>
<p>In the context of NMF, <cite>Hutchins et al. (2008)</cite> used the
variation of the RSS in combination with the algorithm
from <cite>Lee et al. (1999)</cite> to estimate the correct number of
basis vectors. The optimal rank is chosen where the graph
of the RSS first shows an inflexion point, i.e. using a
screeplot-type criterium. See section <em>Rank
estimation</em> in <code><a href="nmf.html">nmf</a></code>.
</p>
<p>Note that this way of estimation may not be suitable for
all models. Indeed, if the NMF optimisation problem is
not based on the Frobenius norm, the RSS is not directly
linked to the quality of approximation of the NMF model.
However, it is often the case that it still decreases
with the rank. </p>
</dd>
</dl>



<h3>References</h3>

<p>Hutchins LN, Murphy SM, Singh P and Graber JH (2008).
&quot;Position-dependent motif characterization using
non-negative matrix factorization.&quot; _Bioinformatics
(Oxford, England)_, *24*(23), pp. 2684-90. ISSN
1367-4811, &lt;URL:
http://dx.doi.org/10.1093/bioinformatics/btn526&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/18852176&gt;.
</p>
<p>Lee DD and Seung HS (1999). &quot;Learning the parts of
objects by non-negative matrix factorization.&quot; _Nature_,
*401*(6755), pp. 788-91. ISSN 0028-0836, &lt;URL:
http://dx.doi.org/10.1038/44565&gt;, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/10548103&gt;.
</p>


<h3>Examples</h3>

<pre>


#----------
# rss,matrix-method
#----------
# RSS bewteeen random matrices
x &lt;- rmatrix(20,10, max=50)
y &lt;- rmatrix(20,10, max=50)
rss(x, y)
rss(x, x + rmatrix(x, max=0.1))

#----------
# rss,ANY-method
#----------
# RSS between an NMF model and a target matrix
x &lt;- rmatrix(20, 10)
y &lt;- rnmf(3, x) # random compatible model
rss(y, x)

# fit a model with nmf(): one should do better
y2 &lt;- nmf(x, 3) # default minimizes the KL-divergence
rss(y2, x)
y2 &lt;- nmf(x, 3, 'lee') # 'lee' minimizes the RSS
rss(y2, x)
</pre>

<hr /><div style="text-align: center;">[Package <em>NMF</em> version 0.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
