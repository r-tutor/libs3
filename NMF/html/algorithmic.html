<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Generic Interface for Algorithms</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for algorithmic-NMF {NMF}"><tr><td>algorithmic-NMF {NMF}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Generic Interface for Algorithms</h2>

<h3>Description</h3>

<p>The functions documented here are S4 generics that define
an general interface for &ndash; optimisation &ndash; algorithms.
</p>
<p>This interface builds upon the broad definition of an
algorithm as a workhorse function to which is associated
auxiliary objects such as an underlying model or an
objective function that measures the adequation of the
model with observed data. It aims at complementing the
interface provided by the <code><a href="../../stats/html/stats-package.html">stats</a></code> package.
</p>


<h3>Usage</h3>

<pre>
  algorithm(object, ...)

  algorithm(object, ...)&lt;-value

  seeding(object, ...)

  seeding(object, ...)&lt;-value

  niter(object, ...)

  niter(object, ...)&lt;-value

  nrun(object, ...)

  objective(object, ...)

  objective(object, ...)&lt;-value

  runtime(object, ...)

  runtime.all(object, ...)

  seqtime(object, ...)

  modelname(object, ...)

  run(object, y, x, ...)

  logs(object, ...)

  compare(object, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p>an object computed using some algorithm, or
that describes an algorithm itself.</p>
</td></tr>
<tr valign="top"><td><code>value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>extra arguments to allow extension</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>data object, e.g. a target matrix</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>a model object used as a starting point by the
algorithm, e.g. a non-empty NMF model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>algorithm</code> and <code>algorithm&lt;-</code> get/set an object
that describes the algorithm used to compute another
object, or with which it is associated. It may be a
simple character string that gives the algorithm's names,
or an object that includes the algorithm's definition
itself (e.g. an <code><a href="NMFStrategy.html">NMFStrategy</a></code> object).
</p>
<p><code>seeding</code> get/set the seeding method used to
initialise the computation of an object, i.e. usually the
function that sets the starting point of an algorithm.
</p>
<p><code>niter</code> and <code>niter&lt;-</code> get/set the number of
iterations performed to compute an object. The function
<code>niter&lt;-</code> would usually be called just before
returning the result of an algorithm, when putting
together data about the fit.
</p>
<p><code>nrun</code> returns the number of times the algorithm has
been run to compute an object. Usually this will be 1,
but may be be more if the algorithm involves multiple
starting points.
</p>
<p><code>objective</code> and <code>objective&lt;-</code> get/set the
objective function associated with an object. Some
methods for <code>objective</code> may also compute the
objective value with respect to some target/observed
data.
</p>
<p><code>runtime</code> returns the CPU time required to compute
an object. This would generally be an object of class
<code><a href="../../base/html/proc.time.html">proc_time</a></code>.
</p>
<p><code>runtime.all</code> returns the CPU time required to
compute a collection of objects, e.g. a sequence of
independent fits.
</p>
<p><code>seqtime</code> returns the sequential CPU time &ndash; that
would be &ndash; required to compute a collection of objects.
It would differ from <code>runtime.all</code> if the
computations were performed in parallel.
</p>
<p><code>modelname</code> returns a the type of model associated
with an object.
</p>
<p><code>run</code> calls the workhorse function that actually
implements a strategy/algorithm, and run it on some data
object.
</p>
<p><code>logs</code> returns the log messages output during the
computation of an object.
</p>
<p><code>compare</code> compares objects obtained from running
separate algorithms.
</p>


<h3>Methods</h3>


<dl>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the name of the algorithm that fitted the NMF
model <code>object</code>. </p>
</dd>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFList")</code>:
Returns the method names used to compute the NMF fits in
the list. It returns <code>NULL</code> if the list is empty.
</p>
<p>See <code><a href="algorithm-commaNMFList-method.html">algorithm,NMFList-method</a></code> for more
details. </p>
</dd>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the name of the common NMF algorithm used to
compute all fits stored in <code>object</code>
</p>
<p>Since all fits are computed with the same algorithm, this
method returns the name of algorithm that computed the
first fit. It returns <code>NULL</code> if the object is empty.
</p>
</dd>
<dt>algorithm</dt><dd><p><code>signature(object = "NMFSeed")</code>:
Returns the workhorse function of the seeding method
described by <code>object</code>. </p>
</dd>
<dt>algorithm</dt><dd><p><code>signature(object =
  "NMFStrategyFunction")</code>: Returns the single R function
that implements the NMF algorithm &ndash; as stored in slot
<code>algorithm</code>. </p>
</dd>
<dt>algorithm&lt;-</dt><dd><p><code>signature(object = "NMFSeed",
  value = "function")</code>: Sets the workhorse function of the
seeding method described by <code>object</code>. </p>
</dd>
<dt>algorithm&lt;-</dt><dd><p><code>signature(object =
  "NMFStrategyFunction", value = "function")</code>: Sets the
function that implements the NMF algorithm, stored in
slot <code>algorithm</code>. </p>
</dd>
<dt>compare</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Compares the fits obtained by separate runs of NMF, in a
single call to <code><a href="nmf.html">nmf</a></code>. </p>
</dd>
<dt>logs</dt><dd><p><code>signature(object = "ANY")</code>: Default
method that returns the value of attribute/slot
<code>'logs'</code> or, if this latter does not exists, the
value of element <code>'logs'</code> if <code>object</code> is a
<code>list</code>. It returns <code>NULL</code> if no logging data
was found. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object = "ANY")</code>:
Default method which returns the class name(s) of
<code>object</code>. This should work for objects representing
models on their own.
</p>
<p>For NMF objects, this is the type of NMF model, that
corresponds to the name of the S4 sub-class of
<code><a href="NMF-class.html">NMF</a></code>, inherited by <code>object</code>. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the type of a fitted NMF model. It is a shortcut
for <code>modelname(fit(object)</code>. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the common type NMF model of all fits stored in
<code>object</code>
</p>
<p>Since all fits are from the same NMF model, this method
returns the model type of the first fit. It returns
<code>NULL</code> if the object is empty. </p>
</dd>
<dt>modelname</dt><dd><p><code>signature(object =
  "NMFStrategy")</code>: Returns the model(s) that an NMF
algorithm can fit. </p>
</dd>
<dt>niter</dt><dd><p><code>signature(object = "NMFfit")</code>: Returns
the number of iteration performed to fit an NMF model,
typically with function <code><a href="nmf.html">nmf</a></code>.
</p>
<p>Currently this data is stored in slot <code>'extra'</code>, but
this might change in the future. </p>
</dd>
<dt>niter&lt;-</dt><dd><p><code>signature(object = "NMFfit", value =
  "numeric")</code>: Sets the number of iteration performed to
fit an NMF model.
</p>
<p>This function is used internally by the function
<code><a href="nmf.html">nmf</a></code>. It is not meant to be called by the
user, except when developing new NMF algorithms
implemented as single function, to set the number of
iterations performed by the algorithm on the seed, before
returning it (see
<code><a href="NMFStrategyFunction-class.html">NMFStrategyFunction</a></code>). </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "ANY")</code>: Default
method that returns the value of attribute &lsquo;nrun&rsquo;.
</p>
<p>Such an attribute my be attached to objects to keep track
of data about the parent fit object (e.g. by method
<code><a href="connectivity.html">consensus</a></code>), which can be used by subsequent
function calls such as plot functions (e.g. see
<code><a href="heatmaps.html">consensusmap</a></code>). This method returns
<code>NULL</code> if no suitable data was found. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitX")</code>: Returns
the number of NMF runs performed to create <code>object</code>.
</p>
<p>It is a pure virtual method defined to ensure <code>nrun</code>
is defined for sub-classes of <code>NMFfitX</code>, which
throws an error if called.
</p>
<p>Note that because the <code><a href="nmf.html">nmf</a></code> function allows
to run the NMF computation keeping only the best fit,
<code>nrun</code> may return a value greater than one, while
only the result of the best run is stored in the object
(cf. option <code>'k'</code> in method <code><a href="nmf.html">nmf</a></code>). </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfit")</code>: This
method always returns 1, since an <code>NMFfit</code> object is
obtained from a single NMF run. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitX1")</code>:
Returns the number of NMF runs performed, amongst which
<code>object</code> was selected as the best fit. </p>
</dd>
<dt>nrun</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the number of runs performed to compute the fits
stored in the list (i.e. the length of the list itself).
</p>
</dd>
<dt>objective</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the objective function associated with the
algorithm that computed the fitted NMF model
<code>object</code>, or the objective value with respect to a
given target matrix <code>y</code> if it is supplied.
</p>
<p>See <code><a href="objective-commaNMFfit-method.html">objective,NMFfit-method</a></code> for more
details. </p>
</dd>
<dt>runtime</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the CPU time required to compute a single NMF
fit. </p>
</dd>
<dt>runtime</dt><dd><p><code>signature(object = "NMFList")</code>:
Returns the CPU time required to compute all NMF fits in
the list. It returns <code>NULL</code> if the list is empty. If
no timing data are available, the sequential time is
returned.
</p>
<p>See <code><a href="runtime-commaNMFList-method.html">runtime,NMFList-method</a></code> for more
details. </p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfit")</code>:
Identical to <code>runtime</code>, since their is a single fit.
</p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfitX")</code>:
Returns the CPU time required to compute all the NMF
runs. It returns <code>NULL</code> if no CPU data is available.
</p>
</dd>
<dt>runtime.all</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
If no time data is available from in slot
&lsquo;runtime.all&rsquo; and argument <code>null=TRUE</code>, then
the sequential time as computed by <code><a href="algorithmic.html">seqtime</a></code>
is returned, and a warning is thrown unless
<code>warning=FALSE</code>.
</p>
<p>See <code><a href="runtime.all-commaNMFfitXn-method.html">runtime.all,NMFfitXn-method</a></code> for more
details. </p>
</dd>
<dt>seeding</dt><dd><p><code>signature(object = "NMFfit")</code>:
Returns the name of the seeding method that generated the
starting point for the NMF algorithm that fitted the NMF
model <code>object</code>. </p>
</dd>
<dt>seeding</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the name of the common seeding method used the
computation of all fits stored in <code>object</code>
</p>
<p>Since all fits are seeded using the same method, this
method returns the name of the seeding method used for
the first fit. It returns <code>NULL</code> if the object is
empty. </p>
</dd>
<dt>seqtime</dt><dd><p><code>signature(object = "NMFList")</code>:
Returns the CPU time that would be required to
sequentially compute all NMF fits stored in
<code>object</code>.
</p>
<p>This method calls the function <code>runtime</code> on each fit
and sum up the results. It returns <code>NULL</code> on an
empty object. </p>
</dd>
<dt>seqtime</dt><dd><p><code>signature(object = "NMFfitXn")</code>:
Returns the CPU time that would be required to
sequentially compute all NMF fits stored in
<code>object</code>.
</p>
<p>This method calls the function <code>runtime</code> on each fit
and sum up the results. It returns <code>NULL</code> on an
empty object. </p>
</dd>
</dl>



<h3>Interface fo NMF algorithms</h3>

<p>This interface is implemented for NMF algorithms by the
classes <code><a href="NMFfit-class.html">NMFfit</a></code>, <code><a href="NMFfitX.html">NMFfitX</a></code> and
<code><a href="NMFStrategy.html">NMFStrategy</a></code>, and their respective
sub-classes. The examples given in this documentation
page are mainly based on this implementation.
</p>


<h3>Examples</h3>

<pre>


#----------
# modelname,ANY-method
#----------
# get the type of an NMF model
modelname(nmfModel(3))
modelname(nmfModel(3, model='NMFns'))
modelname(nmfModel(3, model='NMFOffset'))

#----------
# modelname,NMFStrategy-method
#----------
# get the type of model(s) associated with an NMF algorithm
modelname( nmfAlgorithm('brunet') )
modelname( nmfAlgorithm('nsNMF') )
modelname( nmfAlgorithm('offset') )
</pre>

<hr /><div style="text-align: center;">[Package <em>NMF</em> version 0.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
