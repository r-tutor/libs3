<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Interface for Algorithms: Implementation for Iterative NMF...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for NMFStrategyIterative-class {NMF}"><tr><td>NMFStrategyIterative-class {NMF}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Interface for Algorithms: Implementation for Iterative NMF Algorithms</h2>

<h3>Description</h3>

<p>This class provides a specific implementation for the
generic function <code>run</code> &ndash; concretising the virtual
interface class <code><a href="NMFStrategy-class.html">NMFStrategy</a></code>, for NMF
algorithms that conform to the following iterative schema
(starred numbers indicate mandatory steps):
</p>
 <ul>
<li><p> 1. Initialisation </p>
</li>
<li><p> 2*. Update the
model at each iteration </p>
</li>
<li><p> 3. Stop if some criterion
is satisfied </p>
</li>
<li><p> 4. Wrap up </p>
</li></ul>

<p>This schema could possibly apply to all NMF algorithms,
since these are essentially optimisation algorithms,
almost all of which use iterative methods to approximate
a solution of the optimisation problem. The main
advantage is that it allows to implement updates and
stopping criterion separately, and combine them in
different ways. In particular, many NMF algorithms are
based on multiplicative updates, following the approach
from <cite>Lee et al. (2001)</cite>, which are specially
suitable to be cast into this simple schema.
</p>


<h3>Slots</h3>


<dl>
<dt>onInit</dt><dd><p>optional function that performs some
initialisation or pre-processing on the model, before
starting the iteration loop.</p>
</dd>
<dt>Update</dt><dd><p>mandatory function that implement the
update step, which computes new values for the model,
based on its previous value. It is called at each
iteration, until the stopping criterion is met or the
maximum number of iteration is achieved.</p>
</dd>
<dt>Stop</dt><dd><p>optional function that implements the
stopping criterion. It is called <strong>before</strong> each
Update step. If not provided, the iterations are stopped
after a fixed number of updates.</p>
</dd>
<dt>onReturn</dt><dd><p>optional function that wraps up the
result into an NMF object. It is called just before
returning the</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>run</dt><dd><p><code>signature(object =
  "NMFStrategyIterative", y = "matrix", x = "NMFfit")</code>:
Runs an NMF iterative algorithm on a target matrix
<code>y</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object =
  "NMFStrategyIterative")</code>: Show method for objects of
class <code>NMFStrategyIterative</code> </p>
</dd>
</dl>



<h3>References</h3>

<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization\#0&gt;.
</p>

<hr /><div style="text-align: center;">[Package <em>NMF</em> version 0.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
