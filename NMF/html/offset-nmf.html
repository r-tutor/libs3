<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: NMF Multiplicative Update for NMF with Offset Models</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for nmf_update.euclidean_offset.h {NMF}"><tr><td>nmf_update.euclidean_offset.h {NMF}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>NMF Multiplicative Update for NMF with Offset Models</h2>

<h3>Description</h3>

<p>These update rules proposed by <cite>Badea (2008)</cite> are
modified version of the updates from <cite>Lee et al.
(2001)</cite>, that include an offset/intercept vector, which
models a common baseline for each feature accross all
samples: </p>
<p style="text-align: center;"><i>V \approx W H + I</i></p>

<p><code>nmf_update.euclidean_offset.h</code> and
<code>nmf_update.euclidean_offset.w</code> compute the updated
NMFOffset model, using the optimized <em>C++</em>
implementations.
</p>
<p><code>nmf_update.offset_R</code> implements a complete single
update step, using plain R updates.
</p>
<p><code>nmf_update.offset</code> implements a complete single
update step, using C++-optimised updates.
</p>
<p>Algorithms &lsquo;offset&rsquo; and &lsquo;.R#offset&rsquo; provide
the complete NMF-with-offset algorithm from <cite>Badea
(2008)</cite>, using the C++-optimised and pure R updates
<code><a href="offset-nmf.html">nmf_update.offset</a></code> and
<code><a href="offset-nmf.html">nmf_update.offset_R</a></code> respectively.
</p>


<h3>Usage</h3>

<pre>
  nmf_update.euclidean_offset.h(v, w, h, offset,
    eps = 10^-9, copy = TRUE)

  nmf_update.euclidean_offset.w(v, w, h, offset,
    eps = 10^-9, copy = TRUE)

  nmf_update.offset_R(i, v, x, eps = 10^-9, ...)

  nmf_update.offset(i, v, x, copy = FALSE, eps = 10^-9,
    ...)

  nmfAlgorithm.offset_R(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    eps = 10^-9, stopconv = 40, check.interval = 10)

  nmfAlgorithm.offset(..., .stop = NULL,
    maxIter = nmf.getOption("maxIter") %||% 2000,
    copy = FALSE, eps = 10^-9, stopconv = 40,
    check.interval = 10)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>offset</code></td>
<td>
<p>current value of the offset/intercept
vector. It must be of length equal to the number of rows
in the target matrix.</p>
</td></tr>
<tr valign="top"><td><code>v</code></td>
<td>
<p>target matrix.</p>
</td></tr>
<tr valign="top"><td><code>eps</code></td>
<td>
<p>small numeric value used to ensure numeric
stability, by shifting up entries from zero to this fixed
value.</p>
</td></tr>
<tr valign="top"><td><code>copy</code></td>
<td>
<p>logical that indicates if the update should
be made on the original matrix directly (<code>FALSE</code>) or
on a copy (<code>TRUE</code> - default). With <code>copy=FALSE</code>
the memory footprint is very small, and some speed-up may
be achieved in the case of big matrices. However, greater
care should be taken due the side effect. We recommend
that only experienced users use <code>copy=TRUE</code>.</p>
</td></tr>
<tr valign="top"><td><code>i</code></td>
<td>
<p>current iteration number.</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>current NMF model, as an
<code><a href="NMF-class.html">NMF</a></code> object.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>extra arguments. These are generally not used
and present only to allow other arguments from the main
call to be passed to the initialisation and stopping
criterion functions (slots <code>onInit</code> and <code>Stop</code>
respectively).</p>
</td></tr>
<tr valign="top"><td><code>.stop</code></td>
<td>
<p>specification of a stopping criterion, that
is used instead of the one associated to the NMF
algorithm. It may be specified as: </p>
 <ul>
<li><p> the
access key of a registered stopping criterion; </p>
</li>
<li><p> a
single integer that specifies the exact number of
iterations to perform, which will be honoured unless a
lower value is explicitly passed in argument
<code>maxIter</code>. </p>
</li>
<li><p> a single numeric value that
specifies the stationnarity threshold for the objective
function, used in with <code><a href="stop-NMF.html">nmf.stop.stationary</a></code>;
</p>
</li>
<li><p> a function with signature
<code>(object="NMFStrategy", i="integer", y="matrix",
  x="NMF", ...)</code>, where <code>object</code> is the
<code>NMFStrategy</code> object that describes the algorithm
being run, <code>i</code> is the current iteration, <code>y</code> is
the target matrix and <code>x</code> is the current value of
the NMF model. </p>
</li></ul>
</td></tr>
<tr valign="top"><td><code>maxIter</code></td>
<td>
<p>maximum number of iterations to perform.</p>
</td></tr>
<tr valign="top"><td><code>stopconv</code></td>
<td>
<p>number of iterations intervals over which
the connectivity matrix must not change for stationarity
to be achieved.</p>
</td></tr>
<tr valign="top"><td><code>check.interval</code></td>
<td>
<p>interval (in number of iterations)
on which the stopping criterion is computed.</p>
</td></tr>
<tr valign="top"><td><code>w</code></td>
<td>
<p>current basis matrix</p>
</td></tr>
<tr valign="top"><td><code>h</code></td>
<td>
<p>current coefficient matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The associated model is defined as an
<code><a href="NMFOffset-class.html">NMFOffset</a></code> object. The details of the
multiplicative updates can be found in <cite>Badea
(2008)</cite>. Note that the updates are the ones defined for a
single datasets, not the simultaneous NMF model, which is
fit by algorithm &lsquo;siNMF&rsquo; from formula-based NMF
models.
</p>


<h3>Value</h3>

<p>an <code><a href="NMFOffset-class.html">NMFOffset</a></code> model object.
</p>


<h3>Author(s)</h3>

<p>Original update definition: Liviu Badea
</p>
<p>Port to R and optimisation in C++: Renaud Gaujoux
</p>


<h3>References</h3>

<p>Badea L (2008). &quot;Extracting gene expression profiles
common to colon and pancreatic adenocarcinoma using
simultaneous nonnegative matrix factorization.&quot; _Pacific
Symposium on Biocomputing. Pacific Symposium on
Biocomputing_, *290*, pp. 267-78. ISSN 1793-5091, &lt;URL:
http://www.ncbi.nlm.nih.gov/pubmed/18229692&gt;.
</p>
<p>Lee DD and Seung H (2001). &quot;Algorithms for non-negative
matrix factorization.&quot; _Advances in neural information
processing systems_. &lt;URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization\#0&gt;.
</p>

<hr /><div style="text-align: center;">[Package <em>NMF</em> version 0.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
