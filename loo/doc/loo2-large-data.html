<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Mans Magnusson, Paul Bürkner, Aki Vehtari and Jonah Gabry" />

<meta name="date" content="2020-07-14" />

<title>Using Leave-one-out cross-validation for large data</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Using Leave-one-out cross-validation for large data</h1>
<h4 class="author">Mans Magnusson, Paul Bürkner, Aki Vehtari and Jonah Gabry</h4>
<h4 class="date">2020-07-14</h4>


<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#example-well-water-in-bangladesh">Example: Well water in Bangladesh</a><ul>
<li><a href="#coding-the-stan-model">Coding the Stan model</a></li>
<li><a href="#fitting-the-model-with-rstan">Fitting the model with RStan</a></li>
</ul></li>
<li><a href="#approximate-loo-cv-using-psis-loo-and-subsampling">Approximate LOO-CV using PSIS-LOO and subsampling</a><ul>
<li><a href="#adding-additional-subsamples">Adding additional subsamples</a></li>
<li><a href="#specifying-estimator-and-sampling-method">Specifying estimator and sampling method</a></li>
</ul></li>
<li><a href="#approximate-loo-cv-using-psis-loo-with-posterior-approximations">Approximate LOO-CV using PSIS-LOO with posterior approximations</a><ul>
<li><a href="#combining-the-posterior-approximation-method-with-subsampling">Combining the posterior approximation method with subsampling</a></li>
<li><a href="#comparing-models">Comparing models</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Using Leave-one-out cross-validation for large data}
-->
<p><strong>NOTE: We recommend viewing the fully rendered version of this vignette online at <a href="https://mc-stan.org/loo/articles/" class="uri">https://mc-stan.org/loo/articles/</a></strong></p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This vignette demonstrates how to do leave-one-out cross-validation for large data using the <strong>loo</strong> package and Stan. There are two approaches covered: LOO with subsampling and LOO using approximations to posterior distributions. Some sections from this vignette are excerpted from the papers</p>
<ul>
<li><p>Magnusson, M., Riis Andersen, M., Jonasson, J. and Vehtari, A. (2020). Leave-One-Out Cross-Validation for Model Comparison in Large Data. Proceedings of the 23rd International Conference on Artificial Intelligence and Statistics (AISTATS), in PMLR 108. <a href="https://arxiv.org/abs/2001.00980">arXiv preprint arXiv:2001.00980</a>.</p></li>
<li><p>Magnusson, M., Andersen, M., Jonasson, J. &amp; Vehtari, A. (2019). Bayesian leave-one-out cross-validation for large data. Proceedings of the 36th International Conference on Machine Learning, in PMLR 97:4244-4253 <a href="http://proceedings.mlr.press/v97/magnusson19a.html">online</a>, <a href="https://arxiv.org/abs/1904.10679">arXiv preprint arXiv:1904.10679</a>.</p></li>
<li><p>Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. <em>Statistics and Computing</em>. 27(5), 1413–1432. :10.1007/s11222-016-9696-4. Links: <a href="http://link.springer.com/article/10.1007%2Fs11222-016-9696-4">published</a> | <a href="http://arxiv.org/abs/1507.04544">arXiv preprint</a>.</p></li>
<li><p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry, J. (2019). Pareto smoothed importance sampling. <a href="http://arxiv.org/abs/1507.04544">arXiv preprint arXiv:1507.04544</a>.</p></li>
</ul>
<p>which provide important background for understanding the methods implemented in the package.</p>
</div>
<div id="example-well-water-in-bangladesh" class="section level1">
<h1>Example: Well water in Bangladesh</h1>
<p>We will use the same example as in the vignette <a href="http://mc-stan.org/loo/articles/loo2-with-rstan.html"><em>Writing Stan programs for use with the loo package</em></a>. See that vignette for a description of the problem and data.</p>
<p>The sample size in this example is only <span class="math inline">\(N=3020\)</span>, which is not large enough to <em>require</em> the special methods for large data described in this vignette, but is sufficient for demonstration purposes in this tutorial.</p>
<div id="coding-the-stan-model" class="section level2">
<h2>Coding the Stan model</h2>
<p>Here is the Stan code for fitting the logistic regression model, which we save in a file called <code>logistic.stan</code>:</p>
<pre><code>// save in `logistic.stan`
data {
  int&lt;lower=0&gt; N;             // number of data points
  int&lt;lower=0&gt; P;             // number of predictors (including intercept)
  matrix[N,P] X;              // predictors (including 1s for intercept)
  int&lt;lower=0,upper=1&gt; y[N];  // binary outcome
}
parameters {
  vector[P] beta;
}
model {
  beta ~ normal(0, 1);
  y ~ bernoulli_logit(X * beta);
}</code></pre>
<p>Importantly, unlike the general approach recommended in <a href="http://mc-stan.org/loo/articles/loo2-with-rstan.html"><em>Writing Stan programs for use with the loo package</em></a>, we do <em>not</em> compute the log-likelihood for each observation in the <code>generated quantities</code> block of the Stan program. Here we are assuming we have a large data set (larger than the one we’re actually using in this demonstration) and so it is preferable to instead define a function in R to compute the log-likelihood for each data point when needed rather than storing all of the log-likelihood values in memory.</p>
<p>The log-likelihood in R can be coded as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>llfun_logistic &lt;-<span class="st"> </span><span class="cf">function</span>(data_i, draws) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>  x_i &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(data_i[, <span class="kw">which</span>(<span class="kw">grepl</span>(<span class="kw">colnames</span>(data_i), <span class="dt">pattern =</span> <span class="st">&quot;X&quot;</span>)), <span class="dt">drop=</span><span class="ot">FALSE</span>])</span>
<span id="cb2-3"><a href="#cb2-3"></a>  logit_pred &lt;-<span class="st"> </span>draws <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(x_i)</span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="kw">dbinom</span>(<span class="dt">x =</span> data_i<span class="op">$</span>y, <span class="dt">size =</span> <span class="dv">1</span>, <span class="dt">prob =</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>logit_pred)), <span class="dt">log =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a>}</span></code></pre></div>
<p>The function <code>llfun_logistic()</code> needs to have arguments <code>data_i</code> and <code>draws</code>. Below we will test that the function is working by using the <code>loo_i()</code> function.</p>
</div>
<div id="fitting-the-model-with-rstan" class="section level2">
<h2>Fitting the model with RStan</h2>
<p>Next we fit the model in Stan using the <strong>rstan</strong> package:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">library</span>(<span class="st">&quot;rstan&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">set.seed</span>(<span class="dv">4711</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"># Prepare data</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>url &lt;-<span class="st"> &quot;http://stat.columbia.edu/~gelman/arm/examples/arsenic/wells.dat&quot;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>wells &lt;-<span class="st"> </span><span class="kw">read.table</span>(url)</span>
<span id="cb3-7"><a href="#cb3-7"></a>wells<span class="op">$</span>dist100 &lt;-<span class="st"> </span><span class="kw">with</span>(wells, dist <span class="op">/</span><span class="st"> </span><span class="dv">100</span>)</span>
<span id="cb3-8"><a href="#cb3-8"></a>X &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span>dist100 <span class="op">+</span><span class="st"> </span>arsenic, wells)</span>
<span id="cb3-9"><a href="#cb3-9"></a>standata &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">y =</span> wells<span class="op">$</span><span class="cf">switch</span>, <span class="dt">X =</span> X, <span class="dt">N =</span> <span class="kw">nrow</span>(X), <span class="dt">P =</span> <span class="kw">ncol</span>(X))</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co"># Compile</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>stan_mod &lt;-<span class="st"> </span><span class="kw">stan_model</span>(<span class="st">&quot;logistic.stan&quot;</span>)</span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co"># Fit model</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>fit_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">sampling</span>(stan_mod, <span class="dt">data =</span> standata, <span class="dt">seed =</span> <span class="dv">4711</span>)</span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="kw">print</span>(fit_<span class="dv">1</span>, <span class="dt">pars =</span> <span class="st">&quot;beta&quot;</span>)</span></code></pre></div>
<pre><code>         mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat
beta[1]  0.00       0 0.08 -0.15 -0.05  0.00  0.06  0.16  1933    1
beta[2] -0.89       0 0.10 -1.09 -0.96 -0.89 -0.82 -0.69  2332    1
beta[3]  0.46       0 0.04  0.38  0.43  0.46  0.49  0.54  2051    1</code></pre>
<p>Before we move on to computing LOO we can now test that the log-likelihood function we wrote is working as it should. The <code>loo_i()</code> function is a helper function that can be used to test a log-likelihood function on a single observation.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>parameter_draws_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">extract</span>(fit_<span class="dv">1</span>)<span class="op">$</span>beta</span>
<span id="cb5-2"><a href="#cb5-2"></a>stan_df_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(standata)</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">loo_i</span>(<span class="dv">1</span>, llfun_logistic, <span class="dt">data =</span> stan_df_<span class="dv">1</span>, <span class="dt">draws =</span> parameter_draws_<span class="dv">1</span>)</span></code></pre></div>
<pre><code>$pointwise
    elpd_loo mcse_elpd_loo        p_loo     looic
1 -0.3310342  0.0002908997 0.0003487243 0.6620683
...</code></pre>
</div>
</div>
<div id="approximate-loo-cv-using-psis-loo-and-subsampling" class="section level1">
<h1>Approximate LOO-CV using PSIS-LOO and subsampling</h1>
<p>We can then use the <code>loo_subsample()</code> function to compute the efficient PSIS-LOO approximation to exact LOO-CV using subsampling:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">library</span>(<span class="st">&quot;loo&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a>parameter_draws_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">extract</span>(fit_<span class="dv">1</span>)<span class="op">$</span>beta</span>
<span id="cb7-3"><a href="#cb7-3"></a>stan_df_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(standata)</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">set.seed</span>(<span class="dv">4711</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a>loo_ss_<span class="dv">1</span> &lt;-</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="st">  </span><span class="kw">loo_subsample</span>(</span>
<span id="cb7-8"><a href="#cb7-8"></a>    llfun_logistic,</span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="dt">draws =</span> parameter_draws_<span class="dv">1</span>,</span>
<span id="cb7-10"><a href="#cb7-10"></a>    <span class="dt">data =</span> stan_df_<span class="dv">1</span>,</span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="dt">observations =</span> <span class="dv">100</span> <span class="co"># take a subsample of size 100</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>  )</span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="kw">print</span>(loo_ss_<span class="dv">1</span>)</span></code></pre></div>
<pre><code>Computed from 4000 by 100 subsampled log-likelihood
values from 3020 total observations.

         Estimate   SE subsampling SE
elpd_loo  -1968.5 15.6            0.3
p_loo         3.1  0.1            0.4
looic      3936.9 31.2            0.6
------
Monte Carlo SE of elpd_loo is 0.0.

All Pareto k estimates are good (k &lt; 0.5).
See help(&#39;pareto-k-diagnostic&#39;) for details.</code></pre>
<p>The <code>loo_subsample()</code> function creates an object of class <code>psis_loo_ss</code>, that inherits from <code>psis_loo, loo</code> (the classes of regular <code>loo</code> objects).</p>
<p>The printed output above shows the estimates <span class="math inline">\(\widehat{\mbox{elpd}}_{\rm loo}\)</span> (expected log predictive density), <span class="math inline">\(\widehat{p}_{\rm loo}\)</span> (effective number of parameters), and <span class="math inline">\({\rm looic} =-2\, \widehat{\mbox{elpd}}_{\rm loo}\)</span> (the LOO information criterion). Unlike when using <code>loo()</code>, when using <code>loo_subsample()</code> there is an additional column giving the “subsampling SE”, which reflects the additional uncertainty due to the subsampling used.</p>
<p>The line at the bottom of the printed output provides information about the reliability of the LOO approximation (the interpretation of the <span class="math inline">\(k\)</span> parameter is explained in <code>help(&#39;pareto-k-diagnostic&#39;)</code> and in greater detail in Vehtari, Simpson, Gelman, Yao, and Gabry (2019)). In this case, the message tells us that all of the estimates for <span class="math inline">\(k\)</span> are fine <em>for this given subsample</em>.</p>
<div id="adding-additional-subsamples" class="section level2">
<h2>Adding additional subsamples</h2>
<p>If we are not satisfied with the subsample size (i.e., the accuracy) we can simply add more samples until we are satisfied using the <code>update()</code> method.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">set.seed</span>(<span class="dv">4711</span>)</span>
<span id="cb9-2"><a href="#cb9-2"></a>loo_ss_1b &lt;-<span class="st"> </span><span class="kw">update</span>(loo_ss_<span class="dv">1</span>, <span class="dt">draws =</span> parameter_draws_<span class="dv">1</span>, <span class="dt">data =</span> stan_df_<span class="dv">1</span>, </span>
<span id="cb9-3"><a href="#cb9-3"></a>                    <span class="dt">observations =</span> <span class="dv">200</span>) <span class="co"># subsample 200 instead of 100</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">print</span>(loo_ss_1b)</span></code></pre></div>
<pre><code>Computed from 4000 by 200 subsampled log-likelihood
values from 3020 total observations.

         Estimate   SE subsampling SE
elpd_loo  -1968.3 15.6            0.2
p_loo         3.2  0.1            0.4
looic      3936.7 31.2            0.5
------
Monte Carlo SE of elpd_loo is 0.0.

All Pareto k estimates are good (k &lt; 0.5).
See help(&#39;pareto-k-diagnostic&#39;) for details.</code></pre>
</div>
<div id="specifying-estimator-and-sampling-method" class="section level2">
<h2>Specifying estimator and sampling method</h2>
<p>The performance relies on two components: the estimation method and the approximation used for the elpd. See the documentation for <code>loo_subsample()</code> more information on which estimators and approximations are implemented. The default implementation is using the point log predictive density evaluated at the mean of the posterior (<code>loo_approximation=&quot;plpd&quot;</code>) and the difference estimator (<code>estimator=&quot;diff_srs&quot;</code>). This combination has a focus on fast inference. But we can easily use other estimators as well as other elpd approximations, for example:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">set.seed</span>(<span class="dv">4711</span>)</span>
<span id="cb11-2"><a href="#cb11-2"></a>loo_ss_1c &lt;-</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="st">  </span><span class="kw">loo_subsample</span>(</span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="dt">x =</span> llfun_logistic,</span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="dt">draws =</span> parameter_draws_<span class="dv">1</span>,</span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="dt">data =</span> stan_df_<span class="dv">1</span>,</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="dt">observations =</span> <span class="dv">100</span>,</span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="dt">estimator =</span> <span class="st">&quot;hh_pps&quot;</span>, <span class="co"># use Hansen-Hurwitz</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="dt">loo_approximation =</span> <span class="st">&quot;lpd&quot;</span>, <span class="co"># use lpd instead of plpd</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>    <span class="dt">loo_approximation_draws =</span> <span class="dv">100</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>  )</span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="kw">print</span>(loo_ss_1c)</span></code></pre></div>
<pre><code>Computed from 4000 by 100 subsampled log-likelihood
values from 3020 total observations.

         Estimate   SE subsampling SE
elpd_loo  -1968.9 15.4            0.5
p_loo         3.5  0.2            0.5
looic      3937.9 30.7            1.1
------
Monte Carlo SE of elpd_loo is 0.0.

All Pareto k estimates are good (k &lt; 0.5).
See help(&#39;pareto-k-diagnostic&#39;) for details.</code></pre>
<p>See the documentation and references for <code>loo_subsample()</code> for details on the implemented approximations.</p>
</div>
</div>
<div id="approximate-loo-cv-using-psis-loo-with-posterior-approximations" class="section level1">
<h1>Approximate LOO-CV using PSIS-LOO with posterior approximations</h1>
<p>Using posterior approximations, such as variational inference and Laplace approximations, can further speed-up LOO-CV for large data. Here we demonstrate using a Laplace approximation in Stan.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>fit_laplace &lt;-<span class="st"> </span><span class="kw">optimizing</span>(stan_mod, <span class="dt">data =</span> standata, <span class="dt">draws =</span> <span class="dv">2000</span>, </span>
<span id="cb13-2"><a href="#cb13-2"></a>                          <span class="dt">importance_resampling =</span> <span class="ot">TRUE</span>)</span>
<span id="cb13-3"><a href="#cb13-3"></a>parameter_draws_laplace &lt;-<span class="st"> </span>fit_laplace<span class="op">$</span>theta_tilde <span class="co"># draws from approximate posterior</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>log_p &lt;-<span class="st"> </span>fit_laplace<span class="op">$</span>log_p <span class="co"># log density of the posterior</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>log_g &lt;-<span class="st"> </span>fit_laplace<span class="op">$</span>log_g <span class="co"># log density of the approximation</span></span></code></pre></div>
<p>Using the posterior approximation we can then do LOO-CV by correcting for the posterior approximation when we compute the elpd. To do this we use the <code>loo_approximate_posterior()</code> function.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">set.seed</span>(<span class="dv">4711</span>)</span>
<span id="cb14-2"><a href="#cb14-2"></a>loo_ap_<span class="dv">1</span> &lt;-</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="st">  </span><span class="kw">loo_approximate_posterior</span>(</span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="dt">x =</span> llfun_logistic,</span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="dt">draws =</span> parameter_draws_laplace,</span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="dt">data =</span> stan_df_<span class="dv">1</span>,</span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="dt">log_p =</span> log_p,</span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="dt">log_g =</span> log_g</span>
<span id="cb14-9"><a href="#cb14-9"></a>  )</span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="kw">print</span>(loo_ap_<span class="dv">1</span>)</span></code></pre></div>
<p>The function creates a class, <code>psis_loo_ap</code> that inherits from <code>psis_loo, loo</code>.</p>
<pre><code>Computed from 2000 by 3020 log-likelihood matrix

         Estimate   SE
elpd_loo  -1968.4 15.6
p_loo         3.2  0.2
looic      3936.8 31.2
------
Posterior approximation correction used.
Monte Carlo SE of elpd_loo is 0.0.

Pareto k diagnostic values:
                         Count Pct.    Min. n_eff
(-Inf, 0.5]   (good)     2989  99.0%   1827      
 (0.5, 0.7]   (ok)         31   1.0%   1996      
   (0.7, 1]   (bad)         0   0.0%   &lt;NA&gt;      
   (1, Inf)   (very bad)    0   0.0%   &lt;NA&gt;      

All Pareto k estimates are ok (k &lt; 0.7).
See help(&#39;pareto-k-diagnostic&#39;) for details.</code></pre>
<div id="combining-the-posterior-approximation-method-with-subsampling" class="section level2">
<h2>Combining the posterior approximation method with subsampling</h2>
<p>The posterior approximation correction can also be used together with subsampling:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">set.seed</span>(<span class="dv">4711</span>)</span>
<span id="cb16-2"><a href="#cb16-2"></a>loo_ap_ss_<span class="dv">1</span> &lt;-</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="st">  </span><span class="kw">loo_subsample</span>(</span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="dt">x =</span> llfun_logistic,</span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="dt">draws =</span> parameter_draws_laplace,</span>
<span id="cb16-6"><a href="#cb16-6"></a>    <span class="dt">data =</span> stan_df_<span class="dv">1</span>,</span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="dt">log_p =</span> log_p,</span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="dt">log_g =</span> log_g,</span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="dt">observations =</span> <span class="dv">100</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>  )</span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="kw">print</span>(loo_ap_ss_<span class="dv">1</span>)</span></code></pre></div>
<pre><code>Computed from 2000 by 100 subsampled log-likelihood
values from 3020 total observations.

         Estimate   SE subsampling SE
elpd_loo  -1968.2 15.6            0.4
p_loo         2.9  0.1            0.5
looic      3936.4 31.1            0.8
------
Posterior approximation correction used.
Monte Carlo SE of elpd_loo is 0.0.

Pareto k diagnostic values:
                         Count Pct.    Min. n_eff
(-Inf, 0.5]   (good)     97    97.0%   1971      
 (0.5, 0.7]   (ok)        3     3.0%   1997      
   (0.7, 1]   (bad)       0     0.0%   &lt;NA&gt;      
   (1, Inf)   (very bad)  0     0.0%   &lt;NA&gt;      

All Pareto k estimates are ok (k &lt; 0.7).
See help(&#39;pareto-k-diagnostic&#39;) for details.</code></pre>
<p>The object created is of class <code>psis_loo_ss</code>, which inherits from the <code>psis_loo_ap</code> class previously described.</p>
</div>
<div id="comparing-models" class="section level2">
<h2>Comparing models</h2>
<p>To compare this model to an alternative model for the same data we can use the <code>loo_compare()</code> function just as we would if using <code>loo()</code> instead of <code>loo_subsample()</code> or <code>loo_approximate_posterior()</code>. First we’ll fit a second model to the well-switching data, using <code>log(arsenic)</code> instead of <code>arsenic</code> as a predictor:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>standata<span class="op">$</span>X[, <span class="st">&quot;arsenic&quot;</span>] &lt;-<span class="st"> </span><span class="kw">log</span>(standata<span class="op">$</span>X[, <span class="st">&quot;arsenic&quot;</span>])</span>
<span id="cb18-2"><a href="#cb18-2"></a>fit_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">sampling</span>(stan_mod, <span class="dt">data =</span> standata) </span>
<span id="cb18-3"><a href="#cb18-3"></a>parameter_draws_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">extract</span>(fit_<span class="dv">2</span>)<span class="op">$</span>beta</span>
<span id="cb18-4"><a href="#cb18-4"></a>stan_df_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(standata)</span>
<span id="cb18-5"><a href="#cb18-5"></a></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="co"># recompute subsampling loo for first model for demonstration purposes</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">set.seed</span>(<span class="dv">4711</span>)</span>
<span id="cb18-8"><a href="#cb18-8"></a>loo_ss_<span class="dv">1</span> &lt;-</span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="st">  </span><span class="kw">loo_subsample</span>(</span>
<span id="cb18-10"><a href="#cb18-10"></a>    <span class="dt">x =</span> llfun_logistic,</span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="dt">draws =</span> parameter_draws_<span class="dv">1</span>,</span>
<span id="cb18-12"><a href="#cb18-12"></a>    <span class="dt">data =</span> stan_df_<span class="dv">1</span>,</span>
<span id="cb18-13"><a href="#cb18-13"></a>    <span class="dt">observations =</span> <span class="dv">200</span></span>
<span id="cb18-14"><a href="#cb18-14"></a>  )</span>
<span id="cb18-15"><a href="#cb18-15"></a></span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="co"># compute subsampling loo for a second model (with log-arsenic)</span></span>
<span id="cb18-17"><a href="#cb18-17"></a>loo_ss_<span class="dv">2</span> &lt;-</span>
<span id="cb18-18"><a href="#cb18-18"></a><span class="st">  </span><span class="kw">loo_subsample</span>(</span>
<span id="cb18-19"><a href="#cb18-19"></a>    <span class="dt">x =</span> llfun_logistic,</span>
<span id="cb18-20"><a href="#cb18-20"></a>    <span class="dt">draws =</span> parameter_draws_<span class="dv">2</span>,</span>
<span id="cb18-21"><a href="#cb18-21"></a>    <span class="dt">data =</span> stan_df_<span class="dv">2</span>,</span>
<span id="cb18-22"><a href="#cb18-22"></a>    <span class="dt">observations =</span> <span class="dv">200</span></span>
<span id="cb18-23"><a href="#cb18-23"></a>  )</span>
<span id="cb18-24"><a href="#cb18-24"></a></span>
<span id="cb18-25"><a href="#cb18-25"></a><span class="kw">print</span>(loo_ss_<span class="dv">2</span>)</span></code></pre></div>
<pre><code>Computed from 4000 by 100 subsampled log-likelihood
values from 3020 total observations.

         Estimate   SE subsampling SE
elpd_loo  -1952.0 16.2            0.2
p_loo         2.6  0.1            0.3
looic      3903.9 32.4            0.4
------
Monte Carlo SE of elpd_loo is 0.0.

All Pareto k estimates are good (k &lt; 0.5).
See help(&#39;pareto-k-diagnostic&#39;) for details.</code></pre>
<p>We can now compare the models on LOO using the <code>loo_compare</code> function:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># Compare</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>comp &lt;-<span class="st"> </span><span class="kw">loo_compare</span>(loo_ss_<span class="dv">1</span>, loo_ss_<span class="dv">2</span>)</span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">print</span>(comp)</span></code></pre></div>
<pre><code>Warning: Different subsamples in &#39;model2&#39; and &#39;model1&#39;. Naive diff SE is used.

       elpd_diff se_diff subsampling_se_diff
model2  0.0       0.0     0.0               
model1 16.5      22.5     0.4               </code></pre>
<p>This new object <code>comp</code> contains the estimated difference of expected leave-one-out prediction errors between the two models, along with the standard error. As the warning indicates, because different subsamples were used the comparison will not take the correlations between different observations into account. Here we see that the naive SE is 22.5 and we cannot see any difference in performance between the models.</p>
<p>To force subsampling to use the same observations for each of the models we can simply extract the observations used in <code>loo_ss_1</code> and use them in <code>loo_ss_2</code> by supplying the <code>loo_ss_1</code> object to the <code>observations</code> argument.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>loo_ss_<span class="dv">2</span> &lt;-</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="st">  </span><span class="kw">loo_subsample</span>(</span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span class="dt">x =</span> llfun_logistic,</span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="dt">draws =</span> parameter_draws_<span class="dv">2</span>,</span>
<span id="cb22-5"><a href="#cb22-5"></a>    <span class="dt">data =</span> stan_df_<span class="dv">2</span>,</span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="dt">observations =</span> loo_ss_<span class="dv">1</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>  )</span></code></pre></div>
<p>We could also supply the subsampling indices using the <code>obs_idx()</code> helper function:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>idx &lt;-<span class="st"> </span><span class="kw">obs_idx</span>(loo_ss_<span class="dv">1</span>)</span>
<span id="cb23-2"><a href="#cb23-2"></a>loo_ss_<span class="dv">2</span> &lt;-</span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="st">  </span><span class="kw">loo_subsample</span>(</span>
<span id="cb23-4"><a href="#cb23-4"></a>    <span class="dt">x =</span> llfun_logistic,</span>
<span id="cb23-5"><a href="#cb23-5"></a>    <span class="dt">draws =</span> parameter_draws_<span class="dv">2</span>,</span>
<span id="cb23-6"><a href="#cb23-6"></a>    <span class="dt">data =</span> stan_df_<span class="dv">2</span>,</span>
<span id="cb23-7"><a href="#cb23-7"></a>    <span class="dt">observations =</span> idx</span>
<span id="cb23-8"><a href="#cb23-8"></a>  )</span></code></pre></div>
<pre><code>Simple random sampling with replacement assumed.</code></pre>
<p>This results in a message indicating that we assume these observations to have been sampled with simple random sampling, which is true because we had used the default <code>&quot;diff_srs&quot;</code> estimator for <code>loo_ss_1</code>.</p>
<p>We can now compare the models and estimate the difference based on the same subsampled observations.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>comp &lt;-<span class="st"> </span><span class="kw">loo_compare</span>(loo_ss_<span class="dv">1</span>, loo_ss_<span class="dv">2</span>)</span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">print</span>(comp) </span></code></pre></div>
<pre><code>       elpd_diff se_diff subsampling_se_diff
model2  0.0       0.0     0.0               
model1 16.1       4.4     0.1               </code></pre>
<p>First, notice that now the <code>se_diff</code> is now around 4 (as opposed to 20 when using different subsamples). The first column shows the difference in ELPD relative to the model with the largest ELPD. In this case, the difference in <code>elpd</code> and its scale relative to the approximate standard error of the difference) indicates a preference for the second model (<code>model2</code>). Since the subsampling uncertainty is so small in this case it can effectively be ignored. If we need larger subsamples we can simply add samples using the <code>update()</code> method demonstrated earlier.</p>
<p>It is also possible to compare a subsampled loo computation with a full loo object.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="co"># use loo() instead of loo_subsample() to compute full PSIS-LOO for model 2</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>loo_full_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">loo</span>(<span class="dt">x =</span> llfun_logistic, <span class="dt">draws =</span> parameter_draws_<span class="dv">2</span>, <span class="dt">data =</span> stan_df_<span class="dv">2</span>)</span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="kw">loo_compare</span>(loo_ss_<span class="dv">1</span>, loo_full_<span class="dv">2</span>)</span></code></pre></div>
<pre><code>Estimated elpd_diff using observations included in loo calculations for all models.</code></pre>
<p>Because we are comparing a non-subsampled loo calculation to a subsampled calculation we get the message that only the observations that are included in the loo calculations for both <code>model1</code> and <code>model2</code> are included in the computations for the comparison.</p>
<pre><code>       elpd_diff se_diff subsampling_se_diff
model2  0.0       0.0     0.0               
model1 16.3       4.4     0.3   </code></pre>
<p>Here we actually see an increase in <code>subsampling_se_diff</code>, but this is due to a technical detail not elaborated here. In general, the difference should be better or negligible.</p>
</div>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<p>Gelman, A., and Hill, J. (2007). <em>Data Analysis Using Regression and Multilevel Hierarchical Models.</em> Cambridge University Press.</p>
<p>Stan Development Team (2017). <em>The Stan C++ Library, Version 2.17.0.</em> <a href="http://mc-stan.org" class="uri">http://mc-stan.org</a></p>
<p>Stan Development Team (2018) <em>RStan: the R interface to Stan, Version 2.17.3.</em> <a href="http://mc-stan.org" class="uri">http://mc-stan.org</a></p>
<p>Magnusson, M., Riis Andersen, M., Jonasson, J. and Vehtari, A. (2020). Leave-One-Out Cross-Validation for Model Comparison in Large Data. Proceedings of the 23rd International Conference on Artificial Intelligence and Statistics (AISTATS), in PMLR 108. <a href="https://arxiv.org/abs/2001.00980">arXiv preprint arXiv:2001.00980</a>.</p>
<p>Magnusson, M., Andersen, M., Jonasson, J. &amp; Vehtari, A. (2019). Bayesian leave-one-out cross-validation for large data. Proceedings of the 36th International Conference on Machine Learning, in PMLR 97:4244-4253 <a href="http://proceedings.mlr.press/v97/magnusson19a.html">online</a>, <a href="https://arxiv.org/abs/1904.10679">arXiv preprint arXiv:1904.10679</a>.</p>
<p>Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. <em>Statistics and Computing</em>. 27(5), 1413–1432. :10.1007/s11222-016-9696-4. <a href="http://link.springer.com/article/10.1007%2Fs11222-016-9696-4">online</a>, <a href="http://arxiv.org/abs/1507.04544">arXiv preprint arXiv:1507.04544</a>.</p>
<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry, J. (2019). Pareto smoothed importance sampling. <a href="http://arxiv.org/abs/1507.02646">arXiv preprint arXiv:1507.02646</a>.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
