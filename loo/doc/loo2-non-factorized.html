<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Aki Vehtari, Paul Bürkner and Jonah Gabry" />

<meta name="date" content="2020-07-14" />

<title>Leave-one-out cross-validation for non-factorized models</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Leave-one-out cross-validation for non-factorized models</h1>
<h4 class="author">Aki Vehtari, Paul Bürkner and Jonah Gabry</h4>
<h4 class="date">2020-07-14</h4>


<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#loo-cv-for-multivariate-normal-models">LOO-CV for multivariate normal models</a><ul>
<li><a href="#approximate-loo-cv-using-integrated-importance-sampling">Approximate LOO-CV using integrated importance-sampling</a></li>
<li><a href="#exact-loo-cv-with-re-fitting">Exact LOO-CV with re-fitting</a></li>
</ul></li>
<li><a href="#lagged-sar-models">Lagged SAR models</a><ul>
<li><a href="#case-study-neighborhood-crime-in-columbus-ohio">Case Study: Neighborhood Crime in Columbus, Ohio</a><ul>
<li><a href="#fit-lagged-sar-model">Fit lagged SAR model</a></li>
<li><a href="#approximate-loo-cv">Approximate LOO-CV</a></li>
<li><a href="#exact-loo-cv">Exact LOO-CV</a></li>
</ul></li>
</ul></li>
<li><a href="#working-with-stan-directly">Working with Stan directly</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Leave-one-out cross-validation for non-factorized models}
-->
<p><strong>NOTE: We recommend viewing the fully rendered version of this vignette online at <a href="https://mc-stan.org/loo/articles/" class="uri">https://mc-stan.org/loo/articles/</a></strong></p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>When computing ELPD-based LOO-CV for a Bayesian model we need to compute the log leave-one-out predictive densities <span class="math inline">\(\log{p(y_i | y_{-i})}\)</span> for every response value <span class="math inline">\(y_i, \: i = 1, \ldots, N\)</span>, where <span class="math inline">\(y_{-i}\)</span> denotes all response values except observation <span class="math inline">\(i\)</span>. To obtain <span class="math inline">\(p(y_i | y_{-i})\)</span>, we need to have access to the pointwise likelihood <span class="math inline">\(p(y_i\,|\, y_{-i}, \theta)\)</span> and integrate over the model parameters <span class="math inline">\(\theta\)</span>:</p>
<p><span class="math display">\[
p(y_i\,|\,y_{-i}) =
  \int p(y_i\,|\, y_{-i}, \theta) \, p(\theta\,|\, y_{-i}) \,d \theta
\]</span></p>
<p>Here, <span class="math inline">\(p(\theta\,|\, y_{-i})\)</span> is the leave-one-out posterior distribution for <span class="math inline">\(\theta\)</span>, that is, the posterior distribution for <span class="math inline">\(\theta\)</span> obtained by fitting the model while holding out the <span class="math inline">\(i\)</span>th observation (we will later show how refitting the model to data <span class="math inline">\(y_{-i}\)</span> can be avoided).</p>
<p>If the observation model is formulated directly as the product of the pointwise observation models, we call it a <em>factorized</em> model. In this case, the likelihood is also the product of the pointwise likelihood contributions <span class="math inline">\(p(y_i\,|\, y_{-i}, \theta)\)</span>. To better illustrate possible structures of the observation models, we formally divide <span class="math inline">\(\theta\)</span> into two parts, observation-specific latent variables <span class="math inline">\(f = (f_1, \ldots, f_N)\)</span> and hyperparameters <span class="math inline">\(\psi\)</span>, so that <span class="math inline">\(p(y_i\,|\, y_{-i}, \theta) = p(y_i\,|\, y_{-i}, f_i, \psi)\)</span>. Depending on the model, one of the two parts of <span class="math inline">\(\theta\)</span> may also be empty. In very simple models, such as linear regression models, latent variables are not explicitly presented and response values are conditionally independent given <span class="math inline">\(\psi\)</span>, so that <span class="math inline">\(p(y_i\,|\, y_{-i}, f_i, \psi) = p(y_i \,|\, \psi)\)</span>. The full likelihood can then be written in the familiar form</p>
<p><span class="math display">\[
p(y \,|\, \psi) = \prod_{i=1}^N p(y_i \,|\, \psi),
\]</span></p>
<p>where <span class="math inline">\(y = (y_1, \ldots, y_N)\)</span> denotes the vector of all responses. When the likelihood factorizes this way, the conditional pointwise log-likelihood can be obtained easily by computing <span class="math inline">\(p(y_i\,|\, \psi)\)</span> for each <span class="math inline">\(i\)</span> with computational cost <span class="math inline">\(O(n)\)</span>.</p>
<p>Yet, there are several reasons why a <em>non-factorized</em> observation model may be necessary or preferred. In non-factorized models, the joint likelihood of the response values <span class="math inline">\(p(y \,|\, \theta)\)</span> is not factorized into observation-specific components, but rather given directly as one joint expression. For some models, an analytic factorized formulation is simply not available in which case we speak of a <em>non-factorizable</em> model. Even in models whose observation model can be factorized in principle, it may still be preferable to use a non-factorized form for reasons of efficiency and numerical stability (Bürkner et al. 2020).</p>
<p>Whether a non-factorized model is used by necessity or for efficiency and stability, it comes at the cost of having no direct access to the leave-one-out predictive densities and thus to the overall leave-one-out predictive accuracy. In theory, we can express the observation-specific likelihoods in terms of the joint likelihood via</p>
<p><span class="math display">\[
p(y_i \,|\, y_{i-1}, \theta) = 
  \frac{p(y \,|\, \theta)}{p(y_{-i} \,|\, \theta)} = 
  \frac{p(y \,|\, \theta)}{\int p(y \,|\, \theta) \, d y_i},
\]</span></p>
<p>but the expression on the right-hand side may not always have an analytical solution. Computing <span class="math inline">\(\log p(y_i \,|\, y_{-i}, \theta)\)</span> for non-factorized models is therefore often impossible, or at least inefficient and numerically unstable. However, there is a large class of multivariate normal and Student-<span class="math inline">\(t\)</span> models for which there are efficient analytical solutions available.</p>
<p>More details can be found in our paper about LOO-CV for non-factorized models (Bürkner, Gabry, &amp; Vehtari, 2020), which is available as a preprint on arXiv (<a href="https://arxiv.org/abs/1810.10559" class="uri">https://arxiv.org/abs/1810.10559</a>).</p>
</div>
<div id="loo-cv-for-multivariate-normal-models" class="section level1">
<h1>LOO-CV for multivariate normal models</h1>
<p>In this vignette, we will focus on non-factorized multivariate normal models. Based on results of Sundararajan and Keerthi (2001), Bürkner et al. (2020) show that, for multivariate normal models with coriance matrix <span class="math inline">\(C\)</span>, the LOO predictive mean and standard deviation can be computed as follows:</p>
<p><span class="math display">\[\begin{align}
  \mu_{\tilde{y},-i} &amp;= y_i-\bar{c}_{ii}^{-1} g_i \nonumber \\
  \sigma_{\tilde{y},-i} &amp;= \sqrt{\bar{c}_{ii}^{-1}},
\end{align}\]</span> where <span class="math inline">\(g_i\)</span> and <span class="math inline">\(\bar{c}_{ii}\)</span> are <span class="math display">\[\begin{align}
  g_i &amp;= \left[C^{-1} y\right]_i \nonumber \\
  \bar{c}_{ii} &amp;= \left[C^{-1}\right]_{ii}.
\end{align}\]</span></p>
<p>Using these results, the log predictive density of the <span class="math inline">\(i\)</span>th observation is then computed as</p>
<p><span class="math display">\[
  \log p(y_i \,|\, y_{-i},\theta)
  = - \frac{1}{2}\log(2\pi)
  - \frac{1}{2}\log \sigma^2_{-i}
  - \frac{1}{2}\frac{(y_i-\mu_{-i})^2}{\sigma^2_{-i}}.
\]</span></p>
<p>Expressing this same equation in terms of <span class="math inline">\(g_i\)</span> and <span class="math inline">\(\bar{c}_{ii}\)</span>, the log predictive density becomes:</p>
<p><span class="math display">\[
  \log p(y_i \,|\, y_{-i},\theta)
  = - \frac{1}{2}\log(2\pi)
  + \frac{1}{2}\log \bar{c}_{ii}
  - \frac{1}{2}\frac{g_i^2}{\bar{c}_{ii}}.
\]</span> (Note that Vehtari et al. (2016) has a typo in the corresponding Equation 34.)</p>
<p>From these equations we can now derive a recipe for obtaining the conditional pointwise log-likelihood for <em>all</em> models that can be expressed conditionally in terms of a multivariate normal with invertible covariance matrix <span class="math inline">\(C\)</span>.</p>
<div id="approximate-loo-cv-using-integrated-importance-sampling" class="section level2">
<h2>Approximate LOO-CV using integrated importance-sampling</h2>
<p>The above LOO equations for multivariate normal models are conditional on parameters <span class="math inline">\(\theta\)</span>. Therefore, to obtain the leave-one-out predictive density <span class="math inline">\(p(y_i \,|\, y_{-i})\)</span> we need to integrate over <span class="math inline">\(\theta\)</span>,</p>
<p><span class="math display">\[
p(y_i\,|\,y_{-i}) =
  \int p(y_i\,|\,y_{-i}, \theta) \, p(\theta\,|\,y_{-i}) \,d\theta.
\]</span></p>
<p>Here, <span class="math inline">\(p(\theta\,|\,y_{-i})\)</span> is the leave-one-out posterior distribution for <span class="math inline">\(\theta\)</span>, that is, the posterior distribution for <span class="math inline">\(\theta\)</span> obtained by fitting the model while holding out the <span class="math inline">\(i\)</span>th observation.</p>
<p>To avoid the cost of sampling from <span class="math inline">\(N\)</span> leave-one-out posteriors, it is possible to take the posterior draws <span class="math inline">\(\theta^{(s)}, \, s=1,\ldots,S\)</span>, from the  posterior <span class="math inline">\(p(\theta\,|\,y)\)</span>, and then approximate the above integral using integrated importance sampling (Vehtari et al., 2016, Section 3.6.1):</p>
<p><span class="math display">\[
 p(y_i\,|\,y_{-i}) \approx
   \frac{ \sum_{s=1}^S p(y_i\,|\,y_{-i},\,\theta^{(s)}) \,w_i^{(s)}}{ \sum_{s=1}^S w_i^{(s)}},
\]</span></p>
<p>where <span class="math inline">\(w_i^{(s)}\)</span> are importance weights. First we compute the raw importance ratios</p>
<p><span class="math display">\[
  r_i^{(s)} \propto \frac{1}{p(y_i \,|\, y_{-i}, \,\theta^{(s)})},
\]</span></p>
<p>and then stabilize them using Pareto smoothed importance sampling (PSIS, Vehtari et al, 2019) to obtain the weights <span class="math inline">\(w_i^{(s)}\)</span>. The resulting approximation is referred to as PSIS-LOO (Vehtari et al, 2017).</p>
</div>
<div id="exact-loo-cv-with-re-fitting" class="section level2">
<h2>Exact LOO-CV with re-fitting</h2>
<p>In order to validate the approximate LOO procedure, and also in order to allow exact computations to be made for a small number of leave-one-out folds for which the Pareto <span class="math inline">\(k\)</span> diagnostic (Vehtari et al, 2019) indicates an unstable approximation, we need to consider how we might to do <em>exact</em> leave-one-out CV for a non-factorized model. In the case of a Gaussian process that has the marginalization property, we could just drop the one row and column of <span class="math inline">\(C\)</span> corresponding to the held out out observation. This does not hold in general for multivariate normal models, however, and to keep the original prior we may need to maintain the full covariance matrix <span class="math inline">\(C\)</span> even when one of the observations is left out.</p>
<p>The solution is to model <span class="math inline">\(y_i\)</span> as a missing observation and estimate it along with all of the other model parameters. For a conditional multivariate normal model, <span class="math inline">\(\log p(y_i\,|\,y_{-i})\)</span> can be computed as follows. First, we model <span class="math inline">\(y_i\)</span> as missing and denote the corresponding parameter <span class="math inline">\(y_i^{\mathrm{mis}}\)</span>. Then, we define</p>
<p><span class="math display">\[
y_{\mathrm{mis}(i)} = (y_1, \ldots, y_{i-1}, y_i^{\mathrm{mis}}, y_{i+1}, \ldots, y_N).
\]</span> to be the same as the full set of observations <span class="math inline">\(y\)</span>, except replacing <span class="math inline">\(y_i\)</span> with the parameter <span class="math inline">\(y_i^{\mathrm{mis}}\)</span>.</p>
<p>Second, we compute the LOO predictive mean and standard deviations as above, but replace <span class="math inline">\(y\)</span> with <span class="math inline">\(y_{\mathrm{mis}(i)}\)</span> in the computation of <span class="math inline">\(\mu_{\tilde{y},-i}\)</span>:</p>
<p><span class="math display">\[
\mu_{\tilde{y},-i} = y_{{\mathrm{mis}}(i)}-\bar{c}_{ii}^{-1}g_i,
\]</span></p>
<p>where in this case we have</p>
<p><span class="math display">\[
g_i = \left[ C^{-1} y_{\mathrm{mis}(i)} \right]_i.
\]</span></p>
<p>The conditional log predictive density is then computed with the above <span class="math inline">\(\mu_{\tilde{y},-i}\)</span> and the left out observation <span class="math inline">\(y_i\)</span>:</p>
<p><span class="math display">\[
  \log p(y_i\,|\,y_{-i},\theta)
  = - \frac{1}{2}\log(2\pi)
  - \frac{1}{2}\log \sigma^2_{\tilde{y},-i}
  - \frac{1}{2}\frac{(y_i-\mu_{\tilde{y},-i})^2}{\sigma^2_{\tilde{y},-i}}.
\]</span></p>
<p>Finally, the leave-one-out predictive distribution can then be estimated as</p>
<p><span class="math display">\[
 p(y_i\,|\,y_{-i}) \approx \sum_{s=1}^S p(y_i\,|\,y_{-i}, \theta_{-i}^{(s)}),
\]</span></p>
<p>where <span class="math inline">\(\theta_{-i}^{(s)}\)</span> are draws from the posterior distribution <span class="math inline">\(p(\theta\,|\,y_{\mathrm{mis}(i)})\)</span>.</p>
</div>
</div>
<div id="lagged-sar-models" class="section level1">
<h1>Lagged SAR models</h1>
<p>A common non-factorized multivariate normal model is the simultaneously autoregressive (SAR) model, which is frequently used for spatially correlated data. The lagged SAR model is defined as</p>
<p><span class="math display">\[
y = \rho Wy + \eta + \epsilon
\]</span> or equivalently <span class="math display">\[
(I - \rho W)y = \eta + \epsilon,
\]</span> where <span class="math inline">\(\rho\)</span> is the spatial correlation parameter and <span class="math inline">\(W\)</span> is a user-defined weight matrix. The matrix <span class="math inline">\(W\)</span> has entries <span class="math inline">\(w_{ii} = 0\)</span> along the diagonal and the off-diagonal entries <span class="math inline">\(w_{ij}\)</span> are larger when areas <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are closer to each other. In a linear model, the predictor term <span class="math inline">\(\eta\)</span> is given by <span class="math inline">\(\eta = X \beta\)</span> with design matrix <span class="math inline">\(X\)</span> and regression coefficients <span class="math inline">\(\beta\)</span>. However, since the above equation holds for arbitrary <span class="math inline">\(\eta\)</span>, these results are not restricted to linear models.</p>
<p>If we have <span class="math inline">\(\epsilon \sim {\mathrm N}(0, \,\sigma^2 I)\)</span>, it follows that <span class="math display">\[
(I - \rho W)y \sim {\mathrm N}(\eta, \sigma^2 I),
\]</span> which corresponds to the following log PDF coded in <strong>Stan</strong>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="op">/</span><span class="er">**</span><span class="st"> </span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="st"> </span><span class="er">*</span><span class="st"> </span>Normal log<span class="op">-</span>pdf <span class="cf">for</span> spatially lagged responses</span>
<span id="cb1-3"><a href="#cb1-3"></a> <span class="op">*</span><span class="st"> </span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="st"> </span><span class="er">*</span><span class="st"> </span><span class="er">@</span>param y Vector of response values.</span>
<span id="cb1-5"><a href="#cb1-5"></a> <span class="op">*</span><span class="st"> </span><span class="er">@</span>param mu Mean parameter vector.</span>
<span id="cb1-6"><a href="#cb1-6"></a> <span class="op">*</span><span class="st"> </span><span class="er">@</span>param sigma Positive scalar residual standard deviation.</span>
<span id="cb1-7"><a href="#cb1-7"></a> <span class="op">*</span><span class="st"> </span><span class="er">@</span>param rho Positive scalar autoregressive parameter.</span>
<span id="cb1-8"><a href="#cb1-8"></a> <span class="op">*</span><span class="st"> </span><span class="er">@</span>param W Spatial weight matrix.</span>
<span id="cb1-9"><a href="#cb1-9"></a> <span class="op">*</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="st"> </span><span class="er">*</span><span class="st"> </span><span class="er">@</span>return A scalar to be added to the log posterior.</span>
<span id="cb1-11"><a href="#cb1-11"></a> <span class="op">*</span><span class="er">/</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>real <span class="kw">normal_lagsar_lpdf</span>(vector y, vector mu, real sigma, </span>
<span id="cb1-13"><a href="#cb1-13"></a>                        real rho, matrix W) {</span>
<span id="cb1-14"><a href="#cb1-14"></a>  int N =<span class="st"> </span><span class="kw">rows</span>(y);</span>
<span id="cb1-15"><a href="#cb1-15"></a>  real inv_sigma2 =<span class="st"> </span><span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="kw">square</span>(sigma);</span>
<span id="cb1-16"><a href="#cb1-16"></a>  matrix[N, N] W_tilde =<span class="st"> </span><span class="op">-</span>rho <span class="op">*</span><span class="st"> </span>W;</span>
<span id="cb1-17"><a href="#cb1-17"></a>  vector[N] half_pred;</span>
<span id="cb1-18"><a href="#cb1-18"></a>  </span>
<span id="cb1-19"><a href="#cb1-19"></a>  <span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N) W_tilde[n,n] <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span>;</span>
<span id="cb1-20"><a href="#cb1-20"></a>  </span>
<span id="cb1-21"><a href="#cb1-21"></a>  half_pred =<span class="st"> </span>W_tilde <span class="op">*</span><span class="st"> </span>(y <span class="op">-</span><span class="st"> </span><span class="kw">mdivide_left</span>(W_tilde, mu));</span>
<span id="cb1-22"><a href="#cb1-22"></a>  </span>
<span id="cb1-23"><a href="#cb1-23"></a>  return <span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span><span class="kw">log_determinant</span>(<span class="kw">crossprod</span>(W_tilde) <span class="op">*</span><span class="st"> </span>inv_sigma2) <span class="op">-</span></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="st">         </span><span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span><span class="kw">dot_self</span>(half_pred) <span class="op">*</span><span class="st"> </span>inv_sigma2;</span>
<span id="cb1-25"><a href="#cb1-25"></a>}</span></code></pre></div>
<p>For the purpose of computing LOO-CV, it makes sense to rewrite the SAR model in slightly different form. Conditional on <span class="math inline">\(\rho\)</span>, <span class="math inline">\(\eta\)</span>, and <span class="math inline">\(\sigma\)</span>, if we write</p>
<p><span class="math display">\[\begin{align}
y-(I-\rho W)^{-1}\eta &amp;\sim {\mathrm N}(0, \sigma^2(I-\rho W)^{-1}(I-\rho W)^{-T}),
\end{align}\]</span> or more compactly, with <span class="math inline">\(\widetilde{W}=(I-\rho W)\)</span>, <span class="math display">\[\begin{align}
y-\widetilde{W}^{-1}\eta &amp;\sim {\mathrm N}(0, \sigma^2(\widetilde{W}^{T}\widetilde{W})^{-1}),
\end{align}\]</span></p>
<p>then this has the same form as the zero mean Gaussian process from above. Accordingly, we can compute the leave-one-out predictive densities with the equations from Sundararajan and Keerthi (2001), replacing <span class="math inline">\(y\)</span> with <span class="math inline">\((y-\widetilde{W}^{-1}\eta)\)</span> and taking the covariance matrix <span class="math inline">\(C\)</span> to be <span class="math inline">\(\sigma^2(\widetilde{W}^{T}\widetilde{W})^{-1}\)</span>.</p>
<div id="case-study-neighborhood-crime-in-columbus-ohio" class="section level2">
<h2>Case Study: Neighborhood Crime in Columbus, Ohio</h2>
<p>In order to demonstrate how to carry out the computations implied by these equations, we will first fit a lagged SAR model to data on crime in 49 different neighborhoods of Columbus, Ohio during the year 1980. The data was originally described in Aneslin (1988) and ships with the <strong>spdep</strong> R package.</p>
<p>In addition to the <strong>loo</strong> package, for this analysis we will use the <strong>brms</strong> interface to Stan to generate a Stan program and fit the model, and also the <strong>bayesplot</strong> and <strong>ggplot2</strong> packages for plotting.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">library</span>(<span class="st">&quot;loo&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">library</span>(<span class="st">&quot;brms&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">library</span>(<span class="st">&quot;bayesplot&quot;</span>)</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">library</span>(<span class="st">&quot;ggplot2&quot;</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">color_scheme_set</span>(<span class="st">&quot;brightblue&quot;</span>)</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">theme_set</span>(<span class="kw">theme_default</span>())</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a>SEED &lt;-<span class="st"> </span><span class="dv">10001</span> </span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">set.seed</span>(SEED) <span class="co"># only sets seed for R (seed for Stan set later)</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co"># loads COL.OLD data frame and COL.nb neighbor list</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">data</span>(oldcol, <span class="dt">package =</span> <span class="st">&quot;spdep&quot;</span>) </span></code></pre></div>
<p>The three variables in the data set relevant to this example are:</p>
<ul>
<li><code>CRIME</code>: the number of residential burglaries and vehicle thefts per thousand households in the neighbood</li>
<li><code>HOVAL</code>: housing value in units of $1000 USD</li>
<li><code>INC</code>: household income in units of $1000 USD</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">str</span>(COL.OLD[, <span class="kw">c</span>(<span class="st">&quot;CRIME&quot;</span>, <span class="st">&quot;HOVAL&quot;</span>, <span class="st">&quot;INC&quot;</span>)])</span></code></pre></div>
<p>We will also use the object <code>COL.nb</code>, which is a list containing information about which neighborhoods border each other. From this list we will be able to construct the weight matrix to used to help account for the spatial dependency among the observations.</p>
<div id="fit-lagged-sar-model" class="section level3">
<h3>Fit lagged SAR model</h3>
<p>A model predicting <code>CRIME</code> from <code>INC</code> and <code>HOVAL</code>, while accounting for the spatial dependency via an SAR structure, can be specified in <strong>brms</strong> as follows.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>fit &lt;-<span class="st"> </span><span class="kw">brm</span>(</span>
<span id="cb4-2"><a href="#cb4-2"></a>  CRIME <span class="op">~</span><span class="st"> </span>INC <span class="op">+</span><span class="st"> </span>HOVAL <span class="op">+</span><span class="st"> </span><span class="kw">sar</span>(COL.nb, <span class="dt">type =</span> <span class="st">&quot;lag&quot;</span>), </span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="dt">data =</span> COL.OLD,</span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="dt">data2 =</span> <span class="kw">list</span>(<span class="dt">COL.nb =</span> COL.nb),</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="dt">chains =</span> <span class="dv">4</span>,</span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="dt">seed =</span> SEED</span>
<span id="cb4-7"><a href="#cb4-7"></a>)</span></code></pre></div>
<p>The code above fits the model in <strong>Stan</strong> using a log PDF equivalent to the <code>normal_lagsar_lpdf</code> function we defined above. In the summary output below we see that both higher income and higher housing value predict lower crime rates in the neighborhood. Moreover, there seems to be substantial spatial correlation between adjacent neighborhoods, as indicated by the posterior distribution of the <code>lagsar</code> parameter.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>lagsar &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(fit, <span class="dt">pars =</span> <span class="st">&quot;lagsar&quot;</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>estimates &lt;-<span class="st"> </span><span class="kw">quantile</span>(lagsar, <span class="dt">probs =</span> <span class="kw">c</span>(<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>))</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">mcmc_hist</span>(lagsar) <span class="op">+</span><span class="st"> </span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="st">  </span><span class="kw">vline_at</span>(estimates, <span class="dt">linetype =</span> <span class="dv">2</span>, <span class="dt">size =</span> <span class="dv">1</span>) <span class="op">+</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;lagsar: posterior median and 50% central interval&quot;</span>)</span></code></pre></div>
</div>
<div id="approximate-loo-cv" class="section level3">
<h3>Approximate LOO-CV</h3>
<p>After fitting the model, the next step is to compute the pointwise log-likelihood values needed for approximate LOO-CV. To do this we will use the recipe laid out in the previous sections.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>posterior &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(fit)</span>
<span id="cb6-2"><a href="#cb6-2"></a>y &lt;-<span class="st"> </span>fit<span class="op">$</span>data<span class="op">$</span>CRIME</span>
<span id="cb6-3"><a href="#cb6-3"></a>N &lt;-<span class="st"> </span><span class="kw">length</span>(y)</span>
<span id="cb6-4"><a href="#cb6-4"></a>S &lt;-<span class="st"> </span><span class="kw">nrow</span>(posterior)</span>
<span id="cb6-5"><a href="#cb6-5"></a>loglik &lt;-<span class="st"> </span>yloo &lt;-<span class="st"> </span>sdloo &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">nrow =</span> S, <span class="dt">ncol =</span> N)</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="cf">for</span> (s <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>S) {</span>
<span id="cb6-8"><a href="#cb6-8"></a>  p &lt;-<span class="st"> </span>posterior[s, ]</span>
<span id="cb6-9"><a href="#cb6-9"></a>  eta &lt;-<span class="st"> </span>p<span class="op">$</span>b_Intercept <span class="op">+</span><span class="st"> </span>p<span class="op">$</span>b_INC <span class="op">*</span><span class="st"> </span>fit<span class="op">$</span>data<span class="op">$</span>INC <span class="op">+</span><span class="st"> </span>p<span class="op">$</span>b_HOVAL <span class="op">*</span><span class="st"> </span>fit<span class="op">$</span>data<span class="op">$</span>HOVAL</span>
<span id="cb6-10"><a href="#cb6-10"></a>  W_tilde &lt;-<span class="st"> </span><span class="kw">diag</span>(N) <span class="op">-</span><span class="st"> </span>p<span class="op">$</span>lagsar <span class="op">*</span><span class="st"> </span>spdep<span class="op">::</span><span class="kw">nb2mat</span>(COL.nb)</span>
<span id="cb6-11"><a href="#cb6-11"></a>  Cinv &lt;-<span class="st"> </span><span class="kw">t</span>(W_tilde) <span class="op">%*%</span><span class="st"> </span>W_tilde <span class="op">/</span><span class="st"> </span>p<span class="op">$</span>sigma<span class="op">^</span><span class="dv">2</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>  g &lt;-<span class="st"> </span>Cinv <span class="op">%*%</span><span class="st"> </span>(y <span class="op">-</span><span class="st"> </span><span class="kw">solve</span>(W_tilde, eta))</span>
<span id="cb6-13"><a href="#cb6-13"></a>  cbar &lt;-<span class="st"> </span><span class="kw">diag</span>(Cinv)</span>
<span id="cb6-14"><a href="#cb6-14"></a>  yloo[s, ] &lt;-<span class="st"> </span>y <span class="op">-</span><span class="st"> </span>g <span class="op">/</span><span class="st"> </span>cbar</span>
<span id="cb6-15"><a href="#cb6-15"></a>  sdloo[s, ] &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>cbar)</span>
<span id="cb6-16"><a href="#cb6-16"></a>  loglik[s, ] &lt;-<span class="st"> </span><span class="kw">dnorm</span>(y, yloo[s, ], sdloo[s, ], <span class="dt">log =</span> <span class="ot">TRUE</span>)</span>
<span id="cb6-17"><a href="#cb6-17"></a>}</span>
<span id="cb6-18"><a href="#cb6-18"></a></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="co"># use loo for psis smoothing</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>log_ratios &lt;-<span class="st"> </span><span class="op">-</span>loglik</span>
<span id="cb6-21"><a href="#cb6-21"></a>psis_result &lt;-<span class="st"> </span><span class="kw">psis</span>(log_ratios)</span></code></pre></div>
<p>The quality of the PSIS-LOO approximation can be investigated graphically by plotting the Pareto-k estimate for each observation. Ideally, they should not exceed <span class="math inline">\(0.5\)</span>, but in practice the algorithm turns out to be robust up to values of <span class="math inline">\(0.7\)</span> (Vehtari et al, 2017, 2019). In the plot below, we see that the fourth observation is problematic and so may reduce the accuracy of the LOO-CV approximation.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">plot</span>(psis_result, <span class="dt">label_points =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<p>We can also check that the conditional leave-one-out predictive distribution equations work correctly, for instance, using the last posterior draw:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>yloo_sub &lt;-<span class="st"> </span>yloo[S, ]</span>
<span id="cb8-2"><a href="#cb8-2"></a>sdloo_sub &lt;-<span class="st"> </span>sdloo[S, ]</span>
<span id="cb8-3"><a href="#cb8-3"></a>df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb8-4"><a href="#cb8-4"></a>  <span class="dt">y =</span> y, </span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="dt">yloo =</span> yloo_sub,</span>
<span id="cb8-6"><a href="#cb8-6"></a>  <span class="dt">ymin =</span> yloo_sub <span class="op">-</span><span class="st"> </span>sdloo_sub <span class="op">*</span><span class="st"> </span><span class="dv">2</span>,</span>
<span id="cb8-7"><a href="#cb8-7"></a>  <span class="dt">ymax =</span> yloo_sub <span class="op">+</span><span class="st"> </span>sdloo_sub <span class="op">*</span><span class="st"> </span><span class="dv">2</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>)</span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">ggplot</span>(<span class="dt">data=</span>df, <span class="kw">aes</span>(<span class="dt">x =</span> y, <span class="dt">y =</span> yloo, <span class="dt">ymin =</span> ymin, <span class="dt">ymax =</span> ymax)) <span class="op">+</span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="st">  </span><span class="kw">geom_errorbar</span>(</span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="dt">width =</span> <span class="dv">1</span>, </span>
<span id="cb8-12"><a href="#cb8-12"></a>    <span class="dt">color =</span> <span class="st">&quot;skyblue3&quot;</span>, </span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="dt">position =</span> <span class="kw">position_jitter</span>(<span class="dt">width =</span> <span class="fl">0.25</span>)</span>
<span id="cb8-14"><a href="#cb8-14"></a>  ) <span class="op">+</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="st">  </span><span class="kw">geom_abline</span>(<span class="dt">color =</span> <span class="st">&quot;gray30&quot;</span>, <span class="dt">size =</span> <span class="fl">1.2</span>) <span class="op">+</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="st">  </span><span class="kw">geom_point</span>()</span></code></pre></div>
<p>Finally, we use PSIS-LOO to approximate the expected log predictive density (ELPD) for new data, which we will validate using exact LOO-CV in the upcoming section.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>(psis_loo &lt;-<span class="st"> </span><span class="kw">loo</span>(loglik))</span></code></pre></div>
</div>
<div id="exact-loo-cv" class="section level3">
<h3>Exact LOO-CV</h3>
<p>Exact LOO-CV for the above example is somewhat more involved, as we need to re-fit the model <span class="math inline">\(N\)</span> times and each time model the held-out data point as a parameter. First, we create an empty dummy model that we will update below as we loop over the observations.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># see help(&quot;mi&quot;, &quot;brms&quot;) for details on the mi() usage</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>fit_dummy &lt;-<span class="st"> </span><span class="kw">brm</span>(</span>
<span id="cb10-3"><a href="#cb10-3"></a>  CRIME <span class="op">|</span><span class="st"> </span><span class="kw">mi</span>() <span class="op">~</span><span class="st"> </span>INC <span class="op">+</span><span class="st"> </span>HOVAL <span class="op">+</span><span class="st"> </span><span class="kw">sar</span>(COL.nb, <span class="dt">type =</span> <span class="st">&quot;lag&quot;</span>), </span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="dt">data =</span> COL.OLD,</span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="dt">data2 =</span> <span class="kw">list</span>(<span class="dt">COL.nb =</span> COL.nb),</span>
<span id="cb10-6"><a href="#cb10-6"></a>  <span class="dt">chains =</span> <span class="dv">0</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>)</span></code></pre></div>
<p>Next, we fit the model <span class="math inline">\(N\)</span> times, each time leaving out a single observation and then computing the log predictive density for that observation. For obvious reasons, this takes much longer than the approximation we computed above, but it is necessary in order to validate the approximate LOO-CV method. Thanks to the PSIS-LOO approximation, in general doing these slow exact computations can be avoided.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>S &lt;-<span class="st"> </span><span class="dv">500</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>res &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, N)</span>
<span id="cb11-3"><a href="#cb11-3"></a>loglik &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">nrow =</span> S, <span class="dt">ncol =</span> N)</span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(N)) {</span>
<span id="cb11-5"><a href="#cb11-5"></a>  dat_mi &lt;-<span class="st"> </span>COL.OLD</span>
<span id="cb11-6"><a href="#cb11-6"></a>  dat_mi<span class="op">$</span>CRIME[i] &lt;-<span class="st"> </span><span class="ot">NA</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>  fit_i &lt;-<span class="st"> </span><span class="kw">update</span>(fit_dummy, <span class="dt">newdata =</span> dat_mi, </span>
<span id="cb11-8"><a href="#cb11-8"></a>                  <span class="co"># just for vignette</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>                  <span class="dt">chains =</span> <span class="dv">1</span>, <span class="dt">iter =</span> S <span class="op">*</span><span class="st"> </span><span class="dv">2</span>)</span>
<span id="cb11-10"><a href="#cb11-10"></a>  posterior &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(fit_i)</span>
<span id="cb11-11"><a href="#cb11-11"></a>  yloo &lt;-<span class="st"> </span>sdloo &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, S)</span>
<span id="cb11-12"><a href="#cb11-12"></a>  <span class="cf">for</span> (s <span class="cf">in</span> <span class="kw">seq_len</span>(S)) {</span>
<span id="cb11-13"><a href="#cb11-13"></a>    p &lt;-<span class="st"> </span>posterior[s, ]</span>
<span id="cb11-14"><a href="#cb11-14"></a>    y_miss_i &lt;-<span class="st"> </span>y</span>
<span id="cb11-15"><a href="#cb11-15"></a>    y_miss_i[i] &lt;-<span class="st"> </span>p<span class="op">$</span>Ymi</span>
<span id="cb11-16"><a href="#cb11-16"></a>    eta &lt;-<span class="st"> </span>p<span class="op">$</span>b_Intercept <span class="op">+</span><span class="st"> </span>p<span class="op">$</span>b_INC <span class="op">*</span><span class="st"> </span>fit_i<span class="op">$</span>data<span class="op">$</span>INC <span class="op">+</span><span class="st"> </span>p<span class="op">$</span>b_HOVAL <span class="op">*</span><span class="st"> </span>fit_i<span class="op">$</span>data<span class="op">$</span>HOVAL</span>
<span id="cb11-17"><a href="#cb11-17"></a>    W_tilde &lt;-<span class="st"> </span><span class="kw">diag</span>(N) <span class="op">-</span><span class="st"> </span>p<span class="op">$</span>lagsar <span class="op">*</span><span class="st"> </span>spdep<span class="op">::</span><span class="kw">nb2mat</span>(COL.nb)</span>
<span id="cb11-18"><a href="#cb11-18"></a>    Cinv &lt;-<span class="st"> </span><span class="kw">t</span>(W_tilde) <span class="op">%*%</span><span class="st"> </span>W_tilde <span class="op">/</span><span class="st"> </span>p<span class="op">$</span>sigma<span class="op">^</span><span class="dv">2</span></span>
<span id="cb11-19"><a href="#cb11-19"></a>    g &lt;-<span class="st"> </span>Cinv <span class="op">%*%</span><span class="st"> </span>(y_miss_i <span class="op">-</span><span class="st"> </span><span class="kw">solve</span>(W_tilde, eta))</span>
<span id="cb11-20"><a href="#cb11-20"></a>    cbar &lt;-<span class="st"> </span><span class="kw">diag</span>(Cinv);</span>
<span id="cb11-21"><a href="#cb11-21"></a>    yloo[s] &lt;-<span class="st"> </span>y_miss_i[i] <span class="op">-</span><span class="st"> </span>g[i] <span class="op">/</span><span class="st"> </span>cbar[i]</span>
<span id="cb11-22"><a href="#cb11-22"></a>    sdloo[s] &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>cbar[i])</span>
<span id="cb11-23"><a href="#cb11-23"></a>    loglik[s, i] &lt;-<span class="st"> </span><span class="kw">dnorm</span>(y[i], yloo[s], sdloo[s], <span class="dt">log =</span> <span class="ot">TRUE</span>)</span>
<span id="cb11-24"><a href="#cb11-24"></a>  }</span>
<span id="cb11-25"><a href="#cb11-25"></a>  ypred &lt;-<span class="st"> </span><span class="kw">rnorm</span>(S, yloo, sdloo)</span>
<span id="cb11-26"><a href="#cb11-26"></a>  res[[i]] &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">y =</span> <span class="kw">c</span>(posterior<span class="op">$</span>Ymi, ypred))</span>
<span id="cb11-27"><a href="#cb11-27"></a>  res[[i]]<span class="op">$</span>type &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;pp&quot;</span>, <span class="st">&quot;loo&quot;</span>), <span class="dt">each =</span> S)</span>
<span id="cb11-28"><a href="#cb11-28"></a>  res[[i]]<span class="op">$</span>obs &lt;-<span class="st"> </span>i</span>
<span id="cb11-29"><a href="#cb11-29"></a>}</span>
<span id="cb11-30"><a href="#cb11-30"></a>res &lt;-<span class="st"> </span><span class="kw">do.call</span>(rbind, res)</span></code></pre></div>
<p>A first step in the validation of the pointwise predictive density is to compare the distribution of the implied response values for the left-out observation to the distribution of the <span class="math inline">\(y_i^{\mathrm{mis}}\)</span> posterior-predictive values estimated as part of the model. If the pointwise predictive density is correct, the two distributions should match very closely (up to sampling error). In the plot below, we overlay these two distributions for the first four observations and see that they match very closely (as is the case for all <span class="math inline">\(49\)</span> observations of in this example).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>res_sub &lt;-<span class="st"> </span>res[res<span class="op">$</span>obs <span class="op">%in%</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, ]</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">ggplot</span>(res_sub, <span class="kw">aes</span>(y, <span class="dt">fill =</span> type)) <span class="op">+</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="st">  </span><span class="kw">geom_density</span>(<span class="dt">alpha =</span> <span class="fl">0.6</span>) <span class="op">+</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="st">  </span><span class="kw">facet_wrap</span>(<span class="st">&quot;obs&quot;</span>, <span class="dt">scales =</span> <span class="st">&quot;fixed&quot;</span>, <span class="dt">ncol =</span> <span class="dv">4</span>)</span></code></pre></div>
<p>In the final step, we compute the ELPD based on the exact LOO-CV and compare it to the approximate PSIS-LOO result computed earlier.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>log_mean_exp &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="co"># more stable than log(mean(exp(x)))</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>  max_x &lt;-<span class="st"> </span><span class="kw">max</span>(x)</span>
<span id="cb13-4"><a href="#cb13-4"></a>  max_x <span class="op">+</span><span class="st"> </span><span class="kw">log</span>(<span class="kw">sum</span>(<span class="kw">exp</span>(x <span class="op">-</span><span class="st"> </span>max_x))) <span class="op">-</span><span class="st"> </span><span class="kw">log</span>(<span class="kw">length</span>(x))</span>
<span id="cb13-5"><a href="#cb13-5"></a>}</span>
<span id="cb13-6"><a href="#cb13-6"></a>exact_elpds &lt;-<span class="st"> </span><span class="kw">apply</span>(loglik, <span class="dv">2</span>, log_mean_exp)</span>
<span id="cb13-7"><a href="#cb13-7"></a>exact_elpd &lt;-<span class="st"> </span><span class="kw">sum</span>(exact_elpds)</span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="kw">round</span>(exact_elpd, <span class="dv">1</span>)</span></code></pre></div>
<p>The results of the approximate and exact LOO-CV are similar but not as close as we would expect if there were no problematic observations. We can investigate this issue more closely by plotting the approximate against the exact pointwise ELPD values.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb14-2"><a href="#cb14-2"></a>  <span class="dt">approx_elpd =</span> psis_loo<span class="op">$</span>pointwise[, <span class="st">&quot;elpd_loo&quot;</span>],</span>
<span id="cb14-3"><a href="#cb14-3"></a>  <span class="dt">exact_elpd =</span> exact_elpds</span>
<span id="cb14-4"><a href="#cb14-4"></a>)</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="kw">ggplot</span>(df, <span class="kw">aes</span>(<span class="dt">x =</span> approx_elpd, <span class="dt">y =</span> exact_elpd)) <span class="op">+</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="st">  </span><span class="kw">geom_abline</span>(<span class="dt">color =</span> <span class="st">&quot;gray30&quot;</span>) <span class="op">+</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">2</span>) <span class="op">+</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> df[<span class="dv">4</span>, ], <span class="dt">size =</span> <span class="dv">3</span>, <span class="dt">color =</span> <span class="st">&quot;red3&quot;</span>) <span class="op">+</span></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Approximate elpds&quot;</span>) <span class="op">+</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Exact elpds&quot;</span>) <span class="op">+</span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="st">  </span><span class="kw">coord_fixed</span>(<span class="dt">xlim =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">16</span>, <span class="dv">-3</span>), <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">16</span>, <span class="dv">-3</span>))</span></code></pre></div>
<p>In the plot above the fourth data point —the observation flagged as problematic by the PSIS-LOO approximation— is colored in red and is the clear outlier. Otherwise, the correspondence between the exact and approximate values is strong. In fact, summing over the pointwise ELPD values and leaving out the fourth observation yields practically equivalent results for approximate and exact LOO-CV:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>without_pt_<span class="dv">4</span> &lt;-<span class="st"> </span><span class="kw">c</span>(</span>
<span id="cb15-2"><a href="#cb15-2"></a>  <span class="dt">approx =</span> <span class="kw">sum</span>(psis_loo<span class="op">$</span>pointwise[<span class="op">-</span><span class="dv">4</span>, <span class="st">&quot;elpd_loo&quot;</span>]),</span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="dt">exact =</span> <span class="kw">sum</span>(exact_elpds[<span class="op">-</span><span class="dv">4</span>])  </span>
<span id="cb15-4"><a href="#cb15-4"></a>)</span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="kw">round</span>(without_pt_<span class="dv">4</span>, <span class="dv">1</span>)</span></code></pre></div>
<p>From this we can conclude that the difference we found when including <em>all</em> observations does not indicate a bug in our implementation of the approximate LOO-CV but rather a violation of its assumptions.</p>
</div>
</div>
</div>
<div id="working-with-stan-directly" class="section level1">
<h1>Working with Stan directly</h1>
<p>So far, we have specified the models in brms and only used Stan implicitely behind the scenes. This allowed us to focus on the primary purpose of validating approximate LOO-CV for non-factorized models. However, we would also like to show how everything can be set up in Stan directly. The Stan code brms generates is human readable and so we can use it to learn some of the essential aspects of Stan and the particular model we are implementing. The Stan program below is a slightly modified version of the code extracted via <code>stancode(fit_dummy)</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="op">/</span><span class="er">/</span><span class="st"> </span>generated with brms <span class="dv">2</span>.<span class="fl">2.0</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>functions {</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="op">/</span><span class="er">**</span><span class="st"> </span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="st"> </span><span class="er">*</span><span class="st"> </span>Normal log<span class="op">-</span>pdf <span class="cf">for</span> spatially lagged responses</span>
<span id="cb16-5"><a href="#cb16-5"></a> <span class="op">*</span><span class="st"> </span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="st"> </span><span class="er">*</span><span class="st"> </span><span class="er">@</span>param y Vector of response values.</span>
<span id="cb16-7"><a href="#cb16-7"></a> <span class="op">*</span><span class="st"> </span><span class="er">@</span>param mu Mean parameter vector.</span>
<span id="cb16-8"><a href="#cb16-8"></a> <span class="op">*</span><span class="st"> </span><span class="er">@</span>param sigma Positive scalar residual standard deviation.</span>
<span id="cb16-9"><a href="#cb16-9"></a> <span class="op">*</span><span class="st"> </span><span class="er">@</span>param rho Positive scalar autoregressive parameter.</span>
<span id="cb16-10"><a href="#cb16-10"></a> <span class="op">*</span><span class="st"> </span><span class="er">@</span>param W Spatial weight matrix.</span>
<span id="cb16-11"><a href="#cb16-11"></a> <span class="op">*</span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="st"> </span><span class="er">*</span><span class="st"> </span><span class="er">@</span>return A scalar to be added to the log posterior.</span>
<span id="cb16-13"><a href="#cb16-13"></a> <span class="op">*</span><span class="er">/</span></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="st">  </span>real <span class="kw">normal_lagsar_lpdf</span>(vector y, vector mu, real sigma,</span>
<span id="cb16-15"><a href="#cb16-15"></a>                          real rho, matrix W) {</span>
<span id="cb16-16"><a href="#cb16-16"></a>    int N =<span class="st"> </span><span class="kw">rows</span>(y);</span>
<span id="cb16-17"><a href="#cb16-17"></a>    real inv_sigma2 =<span class="st"> </span><span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="kw">square</span>(sigma);</span>
<span id="cb16-18"><a href="#cb16-18"></a>    matrix[N, N] W_tilde =<span class="st"> </span><span class="op">-</span>rho <span class="op">*</span><span class="st"> </span>W;</span>
<span id="cb16-19"><a href="#cb16-19"></a>    vector[N] half_pred;</span>
<span id="cb16-20"><a href="#cb16-20"></a>    <span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N) W_tilde[n, n] <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span>;</span>
<span id="cb16-21"><a href="#cb16-21"></a>    half_pred =<span class="st"> </span>W_tilde <span class="op">*</span><span class="st"> </span>(y <span class="op">-</span><span class="st"> </span><span class="kw">mdivide_left</span>(W_tilde, mu));</span>
<span id="cb16-22"><a href="#cb16-22"></a>    return <span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span><span class="kw">log_determinant</span>(<span class="kw">crossprod</span>(W_tilde) <span class="op">*</span><span class="st"> </span>inv_sigma2) <span class="op">-</span></span>
<span id="cb16-23"><a href="#cb16-23"></a><span class="st">           </span><span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span><span class="kw">dot_self</span>(half_pred) <span class="op">*</span><span class="st"> </span>inv_sigma2;</span>
<span id="cb16-24"><a href="#cb16-24"></a>  }</span>
<span id="cb16-25"><a href="#cb16-25"></a>}</span>
<span id="cb16-26"><a href="#cb16-26"></a>data {</span>
<span id="cb16-27"><a href="#cb16-27"></a>  int<span class="op">&lt;</span>lower=<span class="dv">1</span><span class="op">&gt;</span><span class="st"> </span>N;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>total number of observations</span>
<span id="cb16-28"><a href="#cb16-28"></a>  vector[N] Y;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>response variable</span>
<span id="cb16-29"><a href="#cb16-29"></a>  int<span class="op">&lt;</span>lower=<span class="dv">0</span><span class="op">&gt;</span><span class="st"> </span>Nmi;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>number of missings</span>
<span id="cb16-30"><a href="#cb16-30"></a>  int<span class="op">&lt;</span>lower=<span class="dv">1</span><span class="op">&gt;</span><span class="st"> </span>Jmi[Nmi];  <span class="op">/</span><span class="er">/</span><span class="st"> </span>positions of missings</span>
<span id="cb16-31"><a href="#cb16-31"></a>  int<span class="op">&lt;</span>lower=<span class="dv">1</span><span class="op">&gt;</span><span class="st"> </span>K;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>number of population<span class="op">-</span>level effects</span>
<span id="cb16-32"><a href="#cb16-32"></a>  matrix[N, K] X;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>population<span class="op">-</span>level design matrix</span>
<span id="cb16-33"><a href="#cb16-33"></a>  matrix[N, N] W;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>spatial weight matrix</span>
<span id="cb16-34"><a href="#cb16-34"></a>  int prior_only;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>should the likelihood be ignored?</span>
<span id="cb16-35"><a href="#cb16-35"></a>}</span>
<span id="cb16-36"><a href="#cb16-36"></a>transformed data {</span>
<span id="cb16-37"><a href="#cb16-37"></a>  int Kc =<span class="st"> </span>K <span class="op">-</span><span class="st"> </span><span class="dv">1</span>;</span>
<span id="cb16-38"><a href="#cb16-38"></a>  matrix[N, K <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] Xc;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>centered version of X</span>
<span id="cb16-39"><a href="#cb16-39"></a>  vector[K <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] means_X;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>column means of X before centering</span>
<span id="cb16-40"><a href="#cb16-40"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>K) {</span>
<span id="cb16-41"><a href="#cb16-41"></a>    means_X[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] =<span class="st"> </span><span class="kw">mean</span>(X[, i]);</span>
<span id="cb16-42"><a href="#cb16-42"></a>    Xc[, i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] =<span class="st"> </span>X[, i] <span class="op">-</span><span class="st"> </span>means_X[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>];</span>
<span id="cb16-43"><a href="#cb16-43"></a>  }</span>
<span id="cb16-44"><a href="#cb16-44"></a>}</span>
<span id="cb16-45"><a href="#cb16-45"></a>parameters {</span>
<span id="cb16-46"><a href="#cb16-46"></a>  vector[Nmi] Ymi;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>estimated missings</span>
<span id="cb16-47"><a href="#cb16-47"></a>  vector[Kc] b;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>population<span class="op">-</span>level effects</span>
<span id="cb16-48"><a href="#cb16-48"></a>  real temp_Intercept;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>temporary intercept</span>
<span id="cb16-49"><a href="#cb16-49"></a>  real<span class="op">&lt;</span>lower=<span class="dv">0</span><span class="op">&gt;</span><span class="st"> </span>sigma;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>residual SD</span>
<span id="cb16-50"><a href="#cb16-50"></a>  real<span class="op">&lt;</span>lower=<span class="dv">0</span>,upper=<span class="dv">1</span><span class="op">&gt;</span><span class="st"> </span>lagsar;  <span class="op">/</span><span class="er">/</span><span class="st"> </span>SAR parameter</span>
<span id="cb16-51"><a href="#cb16-51"></a>}</span>
<span id="cb16-52"><a href="#cb16-52"></a>transformed parameters {</span>
<span id="cb16-53"><a href="#cb16-53"></a>}</span>
<span id="cb16-54"><a href="#cb16-54"></a>model {</span>
<span id="cb16-55"><a href="#cb16-55"></a>  vector[N] Yl =<span class="st"> </span>Y;</span>
<span id="cb16-56"><a href="#cb16-56"></a>  vector[N] mu =<span class="st"> </span>Xc <span class="op">*</span><span class="st"> </span>b <span class="op">+</span><span class="st"> </span>temp_Intercept;</span>
<span id="cb16-57"><a href="#cb16-57"></a>  Yl[Jmi] =<span class="st"> </span>Ymi;</span>
<span id="cb16-58"><a href="#cb16-58"></a>  <span class="op">/</span><span class="er">/</span><span class="st"> </span>priors including all constants</span>
<span id="cb16-59"><a href="#cb16-59"></a>  target <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="kw">student_t_lpdf</span>(temp_Intercept <span class="op">|</span><span class="st"> </span><span class="dv">3</span>, <span class="dv">34</span>, <span class="dv">17</span>);</span>
<span id="cb16-60"><a href="#cb16-60"></a>  target <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="kw">student_t_lpdf</span>(sigma <span class="op">|</span><span class="st"> </span><span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">17</span>)</span>
<span id="cb16-61"><a href="#cb16-61"></a>    <span class="op">-</span><span class="st"> </span><span class="dv">1</span> <span class="op">*</span><span class="st"> </span><span class="kw">student_t_lccdf</span>(<span class="dv">0</span> <span class="op">|</span><span class="st"> </span><span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">17</span>);</span>
<span id="cb16-62"><a href="#cb16-62"></a>  <span class="op">/</span><span class="er">/</span><span class="st"> </span>likelihood including all constants</span>
<span id="cb16-63"><a href="#cb16-63"></a>  <span class="cf">if</span> (<span class="op">!</span>prior_only) {</span>
<span id="cb16-64"><a href="#cb16-64"></a>    target <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="kw">normal_lagsar_lpdf</span>(Yl <span class="op">|</span><span class="st"> </span>mu, sigma, lagsar, W);</span>
<span id="cb16-65"><a href="#cb16-65"></a>  }</span>
<span id="cb16-66"><a href="#cb16-66"></a>}</span>
<span id="cb16-67"><a href="#cb16-67"></a>generated quantities {</span>
<span id="cb16-68"><a href="#cb16-68"></a>  <span class="op">/</span><span class="er">/</span><span class="st"> </span>actual population<span class="op">-</span>level intercept</span>
<span id="cb16-69"><a href="#cb16-69"></a>  real b_Intercept =<span class="st"> </span>temp_Intercept <span class="op">-</span><span class="st"> </span><span class="kw">dot_product</span>(means_X, b);</span>
<span id="cb16-70"><a href="#cb16-70"></a>}</span></code></pre></div>
<p>Here we want to focus on two aspects of the Stan code. First, because there is no built-in function in Stan that calculates the log-likelihood for the lag-SAR model, we define a new <code>normal_lagsar_lpdf</code> function in the <code>functions</code> block of the Stan program. This is the same function we showed earlier in the vignette and it can be used to compute the log-likelihood in an efficient and numerically stable way. The <code>_lpdf</code> suffix used in the function name informs Stan that this is a log probability density function.</p>
<p>Second, this Stan program nicely illustrates how to set up missing value imputation. Instead of just computing the log-likelihood for the observed responses <code>Y</code>, we define a new variable <code>Yl</code> which is equal to <code>Y</code> if the reponse is observed and equal to <code>Ymi</code> if the response is missing. The latter is in turn defined as a parameter and thus estimated along with all other paramters of the model. More details about missing value imputation in Stan can be found in the <em>Missing Data &amp; Partially Known Parameters</em> section of the <a href="http://mc-stan.org/users/documentation/index.html">Stan manual</a>.</p>
<p>The Stan code extracted from brms is not only helpful when learning Stan, but can also drastically speed up the specification of models that are not support by brms. If brms can fit a model similar but not identical to the desired model, we can let brms generate the Stan program for the similar model and then mold it into the program that implements the model we actually want to fit. Rather than calling <code>stancode()</code>, which requires an existing fitted model object, we recommend using <code>make_stancode()</code> and specifying the <code>save_model</code> argument to write the Stan program to a file. The corresponding data can be prepared with <code>make_standata()</code> and then manually amended if needed. Once the code and data have been edited, they can be passed to RStan’s <code>stan()</code> function via the <code>file</code> and <code>data</code> arguments.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>In summary, we have shown how to set up and validate approximate and exact LOO-CV for non-factorized multivariate normal models using Stan with the <strong>brms</strong> and <strong>loo</strong> packages. Although we focused on the particular example of a spatial SAR model, the presented recipe applies more generally to models that can be expressed in terms of a multivariate normal likelihood.</p>
<p><br /></p>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<p>Anselin L. (1988). <em>Spatial econometrics: methods and models</em>. Dordrecht: Kluwer Academic.</p>
<p>Bürkner P. C., Gabry J., &amp; Vehtari A. (2020). Efficient leave-one-out cross-validation for Bayesian non-factorized normal and Student-t models. <a href="https://arxiv.org/abs/1810.10559">ArXiv preprint</a>.</p>
<p>Sundararajan S. &amp; Keerthi S. S. (2001). Predictive approaches for choosing hyperparameters in Gaussian processes. <em>Neural Computation</em>, 13(5), 1103–1118.</p>
<p>Vehtari A., Mononen T., Tolvanen V., Sivula T., &amp; Winther O. (2016). Bayesian leave-one-out cross-validation approximations for Gaussian latent variable models. <em>Journal of Machine Learning Research</em>, 17(103), 1–38. <a href="http://jmlr.org/papers/v17/14-540.html">Online</a>.</p>
<p>Vehtari A., Gelman A., &amp; Gabry J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. <em>Statistics and Computing</em>, 27(5), 1413–1432. :10.1007/s11222-016-9696-4. <a href="http://link.springer.com/article/10.1007/s11222-016-9696-4">Online</a>. <a href="https://arxiv.org/abs/1507.04544">arXiv preprint arXiv:1507.04544</a>.</p>
<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry, J. (2019). Pareto smoothed importance sampling. <a href="https://arxiv.org/abs/1507.02646">arXiv preprint arXiv:1507.02646</a>.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
