<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Aki Vehtari and Jonah Gabry" />

<meta name="date" content="2020-07-14" />

<title>Bayesian Stacking and Pseudo-BMA weights using the loo package</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Bayesian Stacking and Pseudo-BMA weights using the loo package</h1>
<h4 class="author">Aki Vehtari and Jonah Gabry</h4>
<h4 class="date">2020-07-14</h4>


<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#setup">Setup</a></li>
<li><a href="#example-primate-milk">Example: Primate milk</a></li>
<li><a href="#example-oceanic-tool-complexity">Example: Oceanic tool complexity</a></li>
<li><a href="#simpler-coding-using-loo_model_weights-function">Simpler coding using <code>loo_model_weights</code> function</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Bayesian Stacking and Pseudo-BMA weights}
-->
<p><strong>NOTE: We recommend viewing the fully rendered version of this vignette online at <a href="https://mc-stan.org/loo/articles/" class="uri">https://mc-stan.org/loo/articles/</a></strong></p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This vignette demonstrates the new functionality in <strong>loo</strong> v2.0.0 for Bayesian stacking and Pseudo-BMA weighting. In this vignette we can’t provide all of the necessary background on this topic, so we encourage readers to refer to the paper</p>
<ul>
<li>Yao, Y., Vehtari, A., Simpson, D., and Gelman, A. (2018). Using stacking to average Bayesian predictive distributions. In Bayesian Analysis, :10.1214/17-BA1091. <a href="https://projecteuclid.org/euclid.ba/1516093227">Online</a></li>
</ul>
<p>which provides important details on the methods demonstrated in this vignette. Here we just quote from the abstract of the paper:</p>
<blockquote>
<p><strong>Abstract</strong>: Bayesian model averaging is flawed in the <span class="math inline">\(\mathcal{M}\)</span>-open setting in which the true data-generating process is not one of the candidate models being fit. We take the idea of stacking from the point estimation literature and generalize to the combination of predictive distributions. We extend the utility function to any proper scoring rule and use Pareto smoothed importance sampling to efficiently compute the required leave-one-out posterior distributions. We compare stacking of predictive distributions to several alternatives: stacking of means, Bayesian model averaging (BMA), Pseudo-BMA, and a variant of Pseudo-BMA that is stabilized using the Bayesian bootstrap. Based on simulations and real-data applications, we recommend stacking of predictive distributions, with bootstrapped-Pseudo-BMA as an approximate alternative when computation cost is an issue.</p>
</blockquote>
<p>Ideally, we would avoid the Bayesian model combination problem by extending the model to include the separate models as special cases, and preferably as a continuous expansion of the model space. For example, instead of model averaging over different covariate combinations, all potentially relevant covariates should be included in a predictive model (for causal analysis more care is needed) and a prior assumption that only some of the covariates are relevant can be presented with regularized horseshoe prior (Piironen and Vehtari, 2017a). For variable selection we recommend projective predictive variable selection (Piironen and Vehtari, 2017a; <a href="https://cran.r-project.org/package=projpred"><strong>projpred</strong> package</a>).</p>
<p>To demonstrate how to use <strong>loo</strong> package to compute Bayesian stacking and Pseudo-BMA weights, we repeat two simple model averaging examples from Chapters 6 and 10 of <em>Statistical Rethinking</em> by Richard McElreath. In <em>Statistical Rethinking</em> WAIC is used to form weights which are similar to classical “Akaike weights”. Pseudo-BMA weighting using PSIS-LOO for computation is close to these WAIC weights, but named after the Pseudo Bayes Factor by Geisser and Eddy (1979). As discussed below, in general we prefer using stacking rather than WAIC weights or the similar pseudo-BMA weights.</p>
</div>
<div id="setup" class="section level1">
<h1>Setup</h1>
<p>In addition to the <strong>loo</strong> package we will also load the <strong>rstanarm</strong> package for fitting the models.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(rstanarm)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">library</span>(loo)</span></code></pre></div>
</div>
<div id="example-primate-milk" class="section level1">
<h1>Example: Primate milk</h1>
<p>In <em>Statistical Rethinking</em>, McElreath describes the data for the primate milk example as follows:</p>
<blockquote>
<p>A popular hypothesis has it that primates with larger brains produce more energetic milk, so that brains can grow quickly. … The question here is to what extent energy content of milk, measured here by kilocalories, is related to the percent of the brain mass that is neocortex. … We’ll end up needing female body mass as well, to see the masking that hides the relationships among the variables.</p>
</blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span>(milk)</span>
<span id="cb2-2"><a href="#cb2-2"></a>d &lt;-<span class="st"> </span>milk[<span class="kw">complete.cases</span>(milk),]</span>
<span id="cb2-3"><a href="#cb2-3"></a>d<span class="op">$</span>neocortex &lt;-<span class="st"> </span>d<span class="op">$</span>neocortex.perc <span class="op">/</span><span class="dv">100</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">str</span>(d)</span></code></pre></div>
<p>We repeat the analysis in Chapter 6 of <em>Statistical Rethinking</em> using the following four models (here we use the default weakly informative priors in <strong>rstanarm</strong>, while flat priors were used in <em>Statistical Rethinking</em>).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>fit1 &lt;-<span class="st"> </span><span class="kw">stan_glm</span>(kcal.per.g <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">data =</span> d, <span class="dt">seed =</span> <span class="dv">2030</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a>fit2 &lt;-<span class="st"> </span><span class="kw">update</span>(fit1, <span class="dt">formula =</span> kcal.per.g <span class="op">~</span><span class="st"> </span>neocortex)</span>
<span id="cb3-3"><a href="#cb3-3"></a>fit3 &lt;-<span class="st"> </span><span class="kw">update</span>(fit1, <span class="dt">formula =</span> kcal.per.g <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(mass))</span>
<span id="cb3-4"><a href="#cb3-4"></a>fit4 &lt;-<span class="st"> </span><span class="kw">update</span>(fit1, <span class="dt">formula =</span> kcal.per.g <span class="op">~</span><span class="st"> </span>neocortex <span class="op">+</span><span class="st"> </span><span class="kw">log</span>(mass))</span></code></pre></div>
<p>McElreath uses WAIC for model comparison and averaging, so we’ll start by also computing WAIC for these models so we can compare the results to the other options presented later in the vignette. The <strong>loo</strong> package provides <code>waic</code> methods for log-likelihood arrays, matrices and functions. Since we fit our model with rstanarm we can use the <code>waic</code> method provided by the <strong>rstanarm</strong> package (a wrapper around <code>waic</code> from the <strong>loo</strong> package), which allows us to just pass in our fitted model objects instead of first extracting the log-likelihood values.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>waic1 &lt;-<span class="st"> </span><span class="kw">waic</span>(fit1)</span>
<span id="cb4-2"><a href="#cb4-2"></a>waic2 &lt;-<span class="st"> </span><span class="kw">waic</span>(fit2)</span>
<span id="cb4-3"><a href="#cb4-3"></a>waic3 &lt;-<span class="st"> </span><span class="kw">waic</span>(fit3)</span>
<span id="cb4-4"><a href="#cb4-4"></a>waic4 &lt;-<span class="st"> </span><span class="kw">waic</span>(fit4)</span>
<span id="cb4-5"><a href="#cb4-5"></a>waics &lt;-<span class="st"> </span><span class="kw">c</span>(</span>
<span id="cb4-6"><a href="#cb4-6"></a>  waic1<span class="op">$</span>estimates[<span class="st">&quot;elpd_waic&quot;</span>, <span class="dv">1</span>],</span>
<span id="cb4-7"><a href="#cb4-7"></a>  waic2<span class="op">$</span>estimates[<span class="st">&quot;elpd_waic&quot;</span>, <span class="dv">1</span>],</span>
<span id="cb4-8"><a href="#cb4-8"></a>  waic3<span class="op">$</span>estimates[<span class="st">&quot;elpd_waic&quot;</span>, <span class="dv">1</span>],</span>
<span id="cb4-9"><a href="#cb4-9"></a>  waic4<span class="op">$</span>estimates[<span class="st">&quot;elpd_waic&quot;</span>, <span class="dv">1</span>]</span>
<span id="cb4-10"><a href="#cb4-10"></a>)</span></code></pre></div>
<p>We get some warnings when computing WAIC for models 3 and 4, indicating that we shouldn’t trust the WAIC weights we will compute later. Following the recommendation in the warning, we next use the <code>loo</code> methods to compute PSIS-LOO instead. The <strong>loo</strong> package provides <code>loo</code> methods for log-likelihood arrays, matrices, and functions, but since we fit our model with <strong>rstanarm</strong> we can just pass the fitted model objects directly and <strong>rstanarm</strong> will extract the needed values to pass to the <strong>loo</strong> package. (Like <strong>rstanarm</strong>, some other R packages for fitting Stan models, e.g. <strong>brms</strong>, also provide similar methods for interfacing with the <strong>loo</strong> package.)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># note: the loo function accepts a &#39;cores&#39; argument that we recommend specifying</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co"># when working with bigger datasets</span></span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a>loo1 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit1)</span>
<span id="cb5-5"><a href="#cb5-5"></a>loo2 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit2)</span>
<span id="cb5-6"><a href="#cb5-6"></a>loo3 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit3)</span>
<span id="cb5-7"><a href="#cb5-7"></a>loo4 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit4)</span>
<span id="cb5-8"><a href="#cb5-8"></a>lpd_point &lt;-<span class="st"> </span><span class="kw">cbind</span>(</span>
<span id="cb5-9"><a href="#cb5-9"></a>  loo1<span class="op">$</span>pointwise[,<span class="st">&quot;elpd_loo&quot;</span>], </span>
<span id="cb5-10"><a href="#cb5-10"></a>  loo2<span class="op">$</span>pointwise[,<span class="st">&quot;elpd_loo&quot;</span>],</span>
<span id="cb5-11"><a href="#cb5-11"></a>  loo3<span class="op">$</span>pointwise[,<span class="st">&quot;elpd_loo&quot;</span>], </span>
<span id="cb5-12"><a href="#cb5-12"></a>  loo4<span class="op">$</span>pointwise[,<span class="st">&quot;elpd_loo&quot;</span>]</span>
<span id="cb5-13"><a href="#cb5-13"></a>)</span></code></pre></div>
<p>With <code>loo</code> we don’t get any warnings for models 3 and 4, but for illustration of good results, we display the diagnostic details for these models anyway.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">print</span>(loo3)</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">print</span>(loo4)</span></code></pre></div>
<p>One benefit of PSIS-LOO over WAIC is better diagnostics. Here for both models 3 and 4 all <span class="math inline">\(k&lt;0.7\)</span> and the Monte Carlo SE of <code>elpd_loo</code> is 0.1 or less, and we can expect the model comparison to be reliable.</p>
<p>Next we compute and compare 1) WAIC weights, 2) Pseudo-BMA weights without Bayesian bootstrap, 3) Pseudo-BMA+ weights with Bayesian bootstrap, and 4) Bayesian stacking weights.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>waic_wts &lt;-<span class="st"> </span><span class="kw">exp</span>(waics) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">exp</span>(waics))</span>
<span id="cb7-2"><a href="#cb7-2"></a>pbma_wts &lt;-<span class="st"> </span><span class="kw">pseudobma_weights</span>(lpd_point, <span class="dt">BB=</span><span class="ot">FALSE</span>)</span>
<span id="cb7-3"><a href="#cb7-3"></a>pbma_BB_wts &lt;-<span class="st"> </span><span class="kw">pseudobma_weights</span>(lpd_point) <span class="co"># default is BB=TRUE</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>stacking_wts &lt;-<span class="st"> </span><span class="kw">stacking_weights</span>(lpd_point)</span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">round</span>(<span class="kw">cbind</span>(waic_wts, pbma_wts, pbma_BB_wts, stacking_wts), <span class="dv">2</span>)</span></code></pre></div>
<p>With all approaches Model 4 with <code>neocortex</code> and <code>log(mass)</code> gets most of the weight. Based on theory, Pseudo-BMA weights without Bayesian bootstrap should be close to WAIC weights, and we can also see that here. Pseudo-BMA+ weights with Bayesian bootstrap provide more cautious weights further away from 0 and 1 (see Yao et al. (2018) for a discussion of why this can be beneficial and results from related experiments). In this particular example, the Bayesian stacking weights are not much different from the other weights.</p>
<p>One of the benefits of stacking is that it manages well if there are many similar models. Consider for example that there could be many irrelevant covariates that when included would produce a similar model to one of the existing models. To emulate this situation here we simply copy the first model a bunch of times, but you can imagine that instead we would have ten alternative models with about the same predictive performance. WAIC weights for such a scenario would be close to the following:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>waic_wts_demo &lt;-<span class="st"> </span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="st">  </span><span class="kw">exp</span>(waics[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)]) <span class="op">/</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="st">  </span><span class="kw">sum</span>(<span class="kw">exp</span>(waics[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)]))</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">round</span>(waic_wts_demo, <span class="dv">3</span>)</span></code></pre></div>
<p>Notice how much the weight for model 4 is lowered now that more models similar to model 1 (or in this case identical) have been added. Both WAIC weights and Pseudo-BMA approaches first estimate the predictive performance separately for each model and then compute weights based on estimated relative predictive performances. Similar models share similar weights so the weights of other models must be reduced for the total sum of the weights to remain the same.</p>
<p>On the other hand, stacking optimizes the weights <em>jointly</em>, allowing for the very similar models (in this toy example repeated models) to share their weight while more unique models keep their original weights. In our example we can see this difference clearly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">stacking_weights</span>(lpd_point[,<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)])</span></code></pre></div>
<p>Using stacking, the weight for the best model stays essentially unchanged.</p>
</div>
<div id="example-oceanic-tool-complexity" class="section level1">
<h1>Example: Oceanic tool complexity</h1>
<p>Another example we consider is the Kline oceanic tool complexity data, which McElreath describes as follows:</p>
<blockquote>
<p>Different historical island populations possessed tool kits of different size. These kits include fish hooks, axes, boats, hand plows, and many other types of tools. A number of theories predict that larger populations will both develop and sustain more complex tool kits. … It’s also suggested that contact rates among populations effectively increases population [sic, probably should be tool kit] size, as it’s relevant to technological evolution.</p>
</blockquote>
<p>We build models predicting the total number of tools given the log population size and the contact rate (high vs. low).</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">data</span>(Kline)</span>
<span id="cb10-2"><a href="#cb10-2"></a>d &lt;-<span class="st"> </span>Kline</span>
<span id="cb10-3"><a href="#cb10-3"></a>d<span class="op">$</span>log_pop &lt;-<span class="st"> </span><span class="kw">log</span>(d<span class="op">$</span>population)</span>
<span id="cb10-4"><a href="#cb10-4"></a>d<span class="op">$</span>contact_high &lt;-<span class="st"> </span><span class="kw">ifelse</span>(d<span class="op">$</span>contact<span class="op">==</span><span class="st">&quot;high&quot;</span>, <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">str</span>(d)</span></code></pre></div>
<p>We start with a Poisson regression model with the log population size, the contact rate, and an interaction term between them (priors are informative priors as in <em>Statistical Rethinking</em>).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>fit10 &lt;-</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="st">  </span><span class="kw">stan_glm</span>(</span>
<span id="cb11-3"><a href="#cb11-3"></a>    total_tools <span class="op">~</span><span class="st"> </span>log_pop <span class="op">+</span><span class="st"> </span>contact_high <span class="op">+</span><span class="st"> </span>log_pop <span class="op">*</span><span class="st"> </span>contact_high,</span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="dt">family =</span> <span class="kw">poisson</span>(<span class="dt">link =</span> <span class="st">&quot;log&quot;</span>),</span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="dt">data =</span> d,</span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="dt">prior =</span> <span class="kw">normal</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">autoscale =</span> <span class="ot">FALSE</span>),</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="dt">prior_intercept =</span> <span class="kw">normal</span>(<span class="dv">0</span>, <span class="dv">100</span>, <span class="dt">autoscale =</span> <span class="ot">FALSE</span>),</span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="dt">seed =</span> <span class="dv">2030</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>  )</span></code></pre></div>
<p>Before running other models, we check whether Poisson is good choice as the conditional observation model.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>loo10 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit10)</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">print</span>(loo10)</span></code></pre></div>
<p>We get at least one observation with <span class="math inline">\(k&gt;0.7\)</span> and the estimated effective number of parameters <code>p_loo</code> is larger than the total number of parameters in the model. This indicates that Poisson might be too narrow. A negative binomial model might be better, but with so few observations it is not so clear.</p>
<p>We can compute LOO more accurately by running Stan again for the leave-one-out folds with high <span class="math inline">\(k\)</span> estimates. When using <strong>rstanarm</strong> this can be done by specifying the <code>k_threshold</code> argument:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>loo10 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit10, <span class="dt">k_threshold=</span><span class="fl">0.7</span>)</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">print</span>(loo10)</span></code></pre></div>
<p>In this case we see that there is not much difference, and thus it is relatively safe to continue.</p>
<p>As a comparison we also compute WAIC:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>waic10 &lt;-<span class="st"> </span><span class="kw">waic</span>(fit10)</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">print</span>(waic10)</span></code></pre></div>
<p>The WAIC computation is giving warnings and the estimated ELPD is slightly more optimistic. We recommend using the PSIS-LOO results instead.</p>
<p>To assess whether the contact rate and interaction term are useful, we can make a comparison to models without these terms.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>fit11 &lt;-<span class="st"> </span><span class="kw">update</span>(fit10, <span class="dt">formula =</span> total_tools <span class="op">~</span><span class="st"> </span>log_pop <span class="op">+</span><span class="st"> </span>contact_high)</span>
<span id="cb15-2"><a href="#cb15-2"></a>fit12 &lt;-<span class="st"> </span><span class="kw">update</span>(fit10, <span class="dt">formula =</span> total_tools <span class="op">~</span><span class="st"> </span>log_pop)</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>(loo11 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit11))</span>
<span id="cb16-2"><a href="#cb16-2"></a>(loo12 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit12))</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>loo11 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit11, <span class="dt">k_threshold=</span><span class="fl">0.7</span>)</span>
<span id="cb17-2"><a href="#cb17-2"></a>loo12 &lt;-<span class="st"> </span><span class="kw">loo</span>(fit12, <span class="dt">k_threshold=</span><span class="fl">0.7</span>)</span>
<span id="cb17-3"><a href="#cb17-3"></a>lpd_point &lt;-<span class="st"> </span><span class="kw">cbind</span>(</span>
<span id="cb17-4"><a href="#cb17-4"></a>  loo10<span class="op">$</span>pointwise[, <span class="st">&quot;elpd_loo&quot;</span>], </span>
<span id="cb17-5"><a href="#cb17-5"></a>  loo11<span class="op">$</span>pointwise[, <span class="st">&quot;elpd_loo&quot;</span>], </span>
<span id="cb17-6"><a href="#cb17-6"></a>  loo12<span class="op">$</span>pointwise[, <span class="st">&quot;elpd_loo&quot;</span>]</span>
<span id="cb17-7"><a href="#cb17-7"></a>)</span></code></pre></div>
<p>For comparison we’ll also compute WAIC values for these additional models:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>waic11 &lt;-<span class="st"> </span><span class="kw">waic</span>(fit11)</span>
<span id="cb18-2"><a href="#cb18-2"></a>waic12 &lt;-<span class="st"> </span><span class="kw">waic</span>(fit12)</span>
<span id="cb18-3"><a href="#cb18-3"></a>waics &lt;-<span class="st"> </span><span class="kw">c</span>(</span>
<span id="cb18-4"><a href="#cb18-4"></a>  waic10<span class="op">$</span>estimates[<span class="st">&quot;elpd_waic&quot;</span>, <span class="dv">1</span>], </span>
<span id="cb18-5"><a href="#cb18-5"></a>  waic11<span class="op">$</span>estimates[<span class="st">&quot;elpd_waic&quot;</span>, <span class="dv">1</span>], </span>
<span id="cb18-6"><a href="#cb18-6"></a>  waic12<span class="op">$</span>estimates[<span class="st">&quot;elpd_waic&quot;</span>, <span class="dv">1</span>]</span>
<span id="cb18-7"><a href="#cb18-7"></a>)</span></code></pre></div>
<p>The WAIC computation again gives warnings, and we recommend using PSIS-LOO instead.</p>
<p>Finally, we compute 1) WAIC weights, 2) Pseudo-BMA weights without Bayesian bootstrap, 3) Pseudo-BMA+ weights with Bayesian bootstrap, and 4) Bayesian stacking weights.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>waic_wts &lt;-<span class="st"> </span><span class="kw">exp</span>(waics) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">exp</span>(waics))</span>
<span id="cb19-2"><a href="#cb19-2"></a>pbma_wts &lt;-<span class="st"> </span><span class="kw">pseudobma_weights</span>(lpd_point, <span class="dt">BB=</span><span class="ot">FALSE</span>)</span>
<span id="cb19-3"><a href="#cb19-3"></a>pbma_BB_wts &lt;-<span class="st"> </span><span class="kw">pseudobma_weights</span>(lpd_point) <span class="co"># default is BB=TRUE</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>stacking_wts &lt;-<span class="st"> </span><span class="kw">stacking_weights</span>(lpd_point)</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="kw">round</span>(<span class="kw">cbind</span>(waic_wts, pbma_wts, pbma_BB_wts, stacking_wts), <span class="dv">2</span>)</span></code></pre></div>
<p>All weights favor the second model with the log population and the contact rate. WAIC weights and Pseudo-BMA weights (without Bayesian bootstrap) are similar, while Pseudo-BMA+ is more cautious and closer to stacking weights.</p>
<p>It may seem surprising that Bayesian stacking is giving zero weight to the first model, but this is likely due to the fact that the estimated effect for the interaction term is close to zero and thus models 1 and 2 give very similar predictions. In other words, incorporating the model with the interaction (model 1) into the model average doesn’t improve the predictions at all and so model 1 is given a weight of 0. On the other hand, models 2 and 3 are giving slightly different predictions and thus their combination may be slightly better than either alone. This behavior is related to the repeated similar model illustration in the milk example above.</p>
</div>
<div id="simpler-coding-using-loo_model_weights-function" class="section level1">
<h1>Simpler coding using <code>loo_model_weights</code> function</h1>
<p>Although in the examples above we called the <code>stacking_weights</code> and <code>pseudobma_weights</code> functions directly, we can also use the <code>loo_model_weights</code> wrapper, which takes as its input either a list of pointwise log-likelihood matrices or a list of precomputed loo objects. There are also <code>loo_model_weights</code> methods for stanreg objects (fitted model objects from <strong>rstanarm</strong>) as well as fitted model objects from other packages (e.g. <strong>brms</strong>) that do the preparation work for the user (see, e.g., the examples at <code>help(&quot;loo_model_weights&quot;, package = &quot;rstanarm&quot;)</code>).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># using list of loo objects</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>loo_list &lt;-<span class="st"> </span><span class="kw">list</span>(loo10, loo11, loo12)</span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">loo_model_weights</span>(loo_list)</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="kw">loo_model_weights</span>(loo_list, <span class="dt">method =</span> <span class="st">&quot;pseudobma&quot;</span>)</span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="kw">loo_model_weights</span>(loo_list, <span class="dt">method =</span> <span class="st">&quot;pseudobma&quot;</span>, <span class="dt">BB =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<p>McElreath, R. (2016). <em>Statistical rethinking: A Bayesian course with examples in R and Stan</em>. Chapman &amp; Hall/CRC. <a href="http://xcelab.net/rm/statistical-rethinking/" class="uri">http://xcelab.net/rm/statistical-rethinking/</a></p>
<p>Piironen, J. and Vehtari, A. (2017a). Sparsity information and regularization in the horseshoe and other shrinkage priors. In Electronic Journal of Statistics, 11(2):5018-5051. <a href="https://projecteuclid.org/euclid.ejs/1513306866">Online</a>.</p>
<p>Piironen, J. and Vehtari, A. (2017b). Comparison of Bayesian predictive methods for model selection. Statistics and Computing, 27(3):711-735. :10.1007/s11222-016-9649-y. <a href="http://link.springer.com/article/10.1007/s11222-016-9649-y">Online</a>.</p>
<p>Vehtari, A., Gelman, A., and Gabry, J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. <em>Statistics and Computing</em>. 27(5), 1413–1432. :10.1007/s11222-016-9696-4. <a href="http://link.springer.com/article/10.1007%2Fs11222-016-9696-4">online</a>, <a href="http://arxiv.org/abs/1507.04544">arXiv preprint arXiv:1507.04544</a>.</p>
<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry, J. (2019). Pareto smoothed importance sampling. <a href="http://arxiv.org/abs/1507.02646">arXiv preprint arXiv:1507.02646</a>.</p>
<p>Yao, Y., Vehtari, A., Simpson, D., and Gelman, A. (2018). Using stacking to average Bayesian predictive distributions. In Bayesian Analysis, :10.1214/17-BA1091. <a href="https://projecteuclid.org/euclid.ba/1516093227">Online</a>.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
