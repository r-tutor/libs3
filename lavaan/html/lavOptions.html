<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: lavaan Options</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for lavOptions {lavaan}"><tr><td>lavOptions {lavaan}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>lavaan Options</h2>

<h3>Description</h3>

<p>Show the default options used by the <code>lavaan()</code> function. The
options can be changed by passing 'name = value' arguments to the 
<code>lavaan()</code> function call, where they will be added to the '...'
argument.
</p>


<h3>Usage</h3>

<pre>
lavOptions(x = NULL, default = NULL, mimic = "lavaan")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>Character. A character string holding an option name, or a character
string vector holding multiple option names. All option names are converted to
lower case.</p>
</td></tr>
<tr valign="top"><td><code>default</code></td>
<td>
<p>If a single option is specified but not available, this value
is returned.</p>
</td></tr>
<tr valign="top"><td><code>mimic</code></td>
<td>
<p>Character. Adjust the option list for this mimic flag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the full list of options that are accepted by the <code>lavaan()</code>
function, organized in several sections:
</p>
<p>Model features (always available):
</p>

<dl>
<dt><code>meanstructure</code>:</dt><dd><p>If <code>TRUE</code>, the means of the observed
variables enter the model. If <code>"default"</code>, the value is set based
on the user-specified model, and/or the values of other arguments.</p>
</dd>
<dt><code>int.ov.free</code>:</dt><dd><p>If <code>FALSE</code>, the intercepts of the 
observed variables are fixed to zero.</p>
</dd>
<dt><code>int.lv.free</code>:</dt><dd><p>If <code>FALSE</code>, the intercepts of the latent 
variables are fixed to zero.</p>
</dd>
<dt><code>conditional.x</code>:</dt><dd><p>If <code>TRUE</code>, we set up the model 
conditional on the exogenous &lsquo;x&rsquo; covariates; the model-implied sample 
statistics only include the non-x variables. If <code>FALSE</code>, the 
exogenous &lsquo;x&rsquo; variables are modeled jointly with the other variables, and 
the model-implied statistics refect both sets of variables. If
<code>"default"</code>, the value is set depending on the estimator, and
whether or not the model involves categorical endogenous variables.</p>
</dd>
<dt><code>fixed.x</code>:</dt><dd><p>If <code>TRUE</code>, the exogenous &lsquo;x&rsquo; covariates are 
considered fixed variables and the means, variances and covariances of 
these variables are fixed to their sample values. If <code>FALSE</code>, they 
are considered random, and the means, variances and covariances are free 
parameters. If <code>"default"</code>, the value is set depending on the mimic 
option.</p>
</dd>
<dt><code>orthogonal</code>:</dt><dd><p>If <code>TRUE</code>, the exogenous latent variables
are assumed to be uncorrelated.</p>
</dd>
<dt><code>std.lv</code>:</dt><dd><p>If <code>TRUE</code>, the metric of each latent variable 
is determined by fixing their (residual) variances to 1.0. If 
<code>FALSE</code>, the metric of each latent variable is determined by fixing 
the factor loading of the first indicator to 1.0.</p>
</dd>
<dt><code>parameterization</code>:</dt><dd><p>Currently only used if data is 
categorical. If <code>"delta"</code>, the delta parameterization is used. 
If <code>"theta"</code>, the theta parameterization is used.</p>
</dd>
</dl>

<p>Model features (only available for the <code>lavaan()</code> function):
</p>

<dl>
<dt><code>auto.fix.first</code>:</dt><dd><p>If <code>TRUE</code>, the factor loading of the 
first indicator is set to 1.0 for every latent variable.</p>
</dd>
<dt><code>auto.fix.single</code>:</dt><dd><p>If <code>TRUE</code>, the residual variance (if 
included) of an observed indicator is set to zero if it is the only 
indicator of a latent variable.</p>
</dd>
<dt><code>auto.var</code>:</dt><dd><p>If <code>TRUE</code>, the residual variances and the 
variances of exogenous latent variables are included in the model and 
set free.</p>
</dd>
<dt><code>auto.cov.lv.x</code>:</dt><dd><p>If <code>TRUE</code>, the covariances of exogenous 
latent variables are included in the model and set free.</p>
</dd>
<dt><code>auto.cov.y</code>:</dt><dd><p>If <code>TRUE</code>, the covariances of dependent 
variables (both observed and latent) are included in the model and set 
free.</p>
</dd>
<dt><code>auto.th</code>:</dt><dd><p>If <code>TRUE</code>, thresholds for limited dependent 
variables are included in the model and set free.</p>
</dd>
<dt><code>auto.delta</code>:</dt><dd><p>If <code>TRUE</code>, response scaling parameters 
for limited dependent variables are included in the model and set free.</p>
</dd>
</dl>

<p>Data options:
</p>

<dl>
<dt><code>std.ov</code>:</dt><dd><p>If <code>TRUE</code>, all observed variables are 
standardized before entering the analysis.</p>
</dd>
<dt><code>missing</code>:</dt><dd><p>If <code>"listwise"</code>, cases with missing values 
are removed listwise from the data frame before analysis. If 
<code>"direct"</code> or <code>"ml"</code> or <code>"fiml"</code> and the estimator is 
maximum likelihood, Full Information Maximum Likelihood (FIML) 
estimation is used using all available data in the data frame. This is 
only valid if the data are missing completely at random (MCAR) or 
missing at random (MAR). If <code>"default"</code>, the value is set depending 
on the estimator and the mimic option.</p>
</dd>
</dl>

<p>Data summary options:
</p>

<dl>
<dt><code>sample.cov.rescale</code>:</dt><dd><p>If <code>TRUE</code>, the sample covariance 
matrix provided by the user is internally rescaled by multiplying it 
with a factor (N-1)/N.  If <code>"default"</code>, the value is set depending 
on the estimator and the likelihood option: it is set to <code>TRUE</code> if 
maximum likelihood estimation is used and <code>likelihood="normal"</code>, 
and <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>ridge</code>:</dt><dd><p>Numeric. Small constant used for ridging. Only used 
if the sample covariance matrix is non positive definite.</p>
</dd>
</dl>

<p>Multiple group options:
</p>
      
<dl>
<dt><code>group.label</code>:</dt><dd><p>A character vector. The user can specify 
which group (or factor) levels need to be selected from the grouping 
variable, and in which order. If missing, all grouping levels are 
selected, in the order as they appear in the data.</p>
</dd>
<dt><code>group.equal</code>:</dt><dd><p>A vector of character strings. Only used in
a multiple group analysis. Can be one or more of the following:
<code>"loadings"</code>, <code>"intercepts"</code>, <code>"means"</code>,
<code>"thresholds"</code>, <code>"regressions"</code>, <code>"residuals"</code>,
<code>"residual.covariances"</code>, <code>"lv.variances"</code> or
<code>"lv.covariances"</code>, specifying the pattern of equality
constraints across multiple groups.</p>
</dd>
<dt><code>group.partial</code>:</dt><dd><p>A vector of character strings containing 
the labels of the parameters which should be free in all groups (thereby
overriding the group.equal argument for some specific parameters).</p>
</dd>
<dt><code>group.w.free</code>:</dt><dd><p>Logical. If <code>TRUE</code>, the group 
frequencies are considered to be free parameters in the model. In this 
case, a Poisson model is fitted to estimate the group frequencies. If
<code>FALSE</code> (the default), the group frequencies are fixed to their
observed values.</p>
</dd>
</dl>

<p>Estimation options:
</p>

<dl>
<dt><code>estimator</code>:</dt><dd><p>The estimator to be used. Can be one of the 
following: <code>"ML"</code> for maximum likelihood, <code>"GLS"</code> for 
generalized least squares, <code>"WLS"</code> for weighted least squares 
(sometimes called ADF estimation), <code>"ULS"</code> for unweighted least 
squares and <code>"DWLS"</code> for diagonally weighted least squares. These 
are the main options that affect the estimation. For convenience, the 
<code>"ML"</code> option can be extended as <code>"MLM"</code>, <code>"MLMV"</code>, 
<code>"MLMVS"</code>, <code>"MLF"</code>, and <code>"MLR"</code>. 
The estimation will still be plain <code>"ML"</code>, but now
with robust standard errors and a robust (scaled) test statistic. For
<code>"MLM"</code>, <code>"MLMV"</code>, <code>"MLMVS"</code>, classic robust standard
errors are used (<code>se="robust.sem"</code>); for <code>"MLF"</code>, standard
errors are based on first-order derivatives 
(<code>information = "first.order"</code>);
for <code>"MLR"</code>, &lsquo;Huber-White&rsquo; robust standard errors are used
(<code>se="robust.huber.white"</code>). In addition, <code>"MLM"</code> will compute
a Satorra-Bentler scaled (mean adjusted) test statistic
(<code>test="satorra.bentler"</code>) , <code>"MLMVS"</code> will compute a
mean and variance adjusted test statistic (Satterthwaite style)
(<code>test="mean.var.adjusted"</code>), <code>"MLMV"</code> will compute a mean
and variance adjusted test statistic (scaled and shifted)
(<code>test="scaled.shifted"</code>), and <code>"MLR"</code> will
compute a test statistic which is asymptotically
equivalent to the Yuan-Bentler T2-star test statistic
(<code>test="yuan.bentler.mplus"</code>). Analogously,
the estimators <code>"WLSM"</code> and <code>"WLSMV"</code> imply the <code>"DWLS"</code>
estimator (not the <code>"WLS"</code> estimator) with robust standard errors
and a mean or mean and variance adjusted test statistic. Estimators
<code>"ULSM"</code> and <code>"ULSMV"</code> imply the <code>"ULS"</code>
estimator with robust standard errors
and a mean or mean and variance adjusted test statistic.</p>
</dd>
<dt><code>likelihood</code>:</dt><dd><p>Only relevant for ML estimation. If 
<code>"wishart"</code>, the wishart likelihood approach is used. In this 
approach, the covariance matrix has been divided by N-1, and both 
standard errors and test statistics are based on N-1.
If <code>"normal"</code>, the normal likelihood approach is used. Here,
the covariance matrix has been divided by N, and both standard errors
and test statistics are based on N. If <code>"default"</code>, it depends
on the mimic option: if <code>mimic="lavaan"</code> or <code>mimic="Mplus"</code>,
normal likelihood is used; otherwise, wishart likelihood is used.</p>
</dd>
<dt><code>link</code>:</dt><dd><p>Currently only used if estimator is MML. 
If <code>"logit"</code>, a logit link is used for binary and ordered observed 
variables. If <code>"probit"</code>, a probit link is used. If 
<code>"default"</code>, it is currently set to <code>"probit"</code> (but this may 
change).</p>
</dd>
<dt><code>information</code>:</dt><dd><p>If <code>"expected"</code>, the expected 
information matrix is used (to compute the standard errors). If 
<code>"observed"</code>, the observed information matrix is used. 
If <code>"first.order"</code>, the information matrix is based on the
outer product of the casewise scores. See also the options
<code>"h1.information"</code> and <code>"observed.information"</code> for
further control. If <code>"default"</code>, the value is set depending 
on the estimator, the missing argument, and the mimic option.</p>
</dd>
<dt><code>h1.information</code>:</dt><dd><p>If <code>"structured"</code> (the default), the
unrestricted (h1) information part of the (expected, first.order or 
observed if h1 is used) information matrix is based on the structured, 
or model-implied statistics (model-implied covariance matrix, 
model-implied mean vector, etc.). 
If <code>"unstructured"</code>, the unrestricted (h1) information part is
based on sample-based statistics (observed covariance matrix, observed
mean vector, etc.)</p>
</dd>
<dt><code>observed.information</code>:</dt><dd><p>If <code>"hessian"</code>, the observed
information matrix is based on the hessian of the objective function.
If <code>"h1"</code>, an approximation is used that is based on 
the observed information matrix of the unrestricted (h1) model.</p>
</dd>
<dt><code>se</code>:</dt><dd><p>If <code>"standard"</code>, conventional standard errors
are computed based on inverting the (expected, observed or first.order) 
information matrix. If <code>"robust.sem"</code>, conventional robust
standard errors are computed.  If <code>"robust.huber.white"</code>,
standard errors are computed based on the &lsquo;mlr&rsquo; (aka pseudo ML,
Huber-White) approach.
If <code>"robust"</code>, either <code>"robust.sem"</code> or
<code>"robust.huber.white"</code> is used depending on the estimator,
the mimic option, and whether the data are complete or not.
If <code>"boot"</code> or <code>"bootstrap"</code>, bootstrap standard errors are
computed using standard bootstrapping (unless Bollen-Stine bootstrapping
is requested for the test statistic; in this case bootstrap standard
errors are computed using model-based bootstrapping).
If <code>"none"</code>, no standard errors are computed.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>If <code>"standard"</code>, a conventional chi-square test 
is computed. If <code>"Satorra.Bentler"</code>, a Satorra-Bentler scaled test 
statistic is computed. If <code>"Yuan.Bentler"</code>, a Yuan-Bentler scaled 
test statistic is computed. If <code>"Yuan.Bentler.Mplus"</code>, a 
test statistic is computed that is asymptotically equal to the
Yuan-Bentler scaled
test statistic. If <code>"mean.var.adjusted"</code> or 
<code>"Satterthwaite"</code>, a mean and variance adjusted test statistic is 
compute. If <code>"scaled.shifted"</code>, an alternative mean and variance 
adjusted test statistic is computed (as in Mplus version 6 or higher).
If <code>"boot"</code> or <code>"bootstrap"</code> or <code>"Bollen.Stine"</code>, the 
Bollen-Stine bootstrap is used to compute the bootstrap probability value 
of the test statistic. If <code>"default"</code>, the value depends on the
values of other arguments.</p>
</dd>
<dt><code>bootstrap</code>:</dt><dd><p>Number of bootstrap draws, if bootstrapping is 
used.</p>
</dd>
<dt><code>do.fit</code>:</dt><dd><p>If <code>FALSE</code>, the model is not fit, and the 
current starting values of the model parameters are preserved.</p>
</dd>
</dl>

<p>Optimization options:
</p>

<dl>
<dt><code>control</code>:</dt><dd><p>A list containing control parameters passed to 
the external optimizer. By default, lavaan uses <code>"nlminb"</code>. 
See the manpage of <code><a href="../../stats/html/nlminb.html">nlminb</a></code> for an overview of the control 
parameters. If another (external) optimizer is selected, see the
manpage for that optimizer to see the possible control parameters.</p>
</dd>
<dt><code>optim.method</code>:</dt><dd><p>Character. The optimizer that should be
used. For unconstrained optimization (the model syntax
does not include any &quot;==&quot;, &quot;&gt;&quot; or &quot;&lt;&quot; operators),
the available options are <code>"nlminb"</code> (the default), <code>"BFGS"</code> and
<code>"L-BFGS-B"</code>. For constrained
optimization, the only available option is <code>"nlminb.constr"</code>.</p>
</dd>
</dl>

<p>Categorical estimation options:
</p>

<dl>
<dt><code>zero.add</code>:</dt><dd><p>A numeric vector containing two values. These 
values affect the calculation of polychoric correlations when some 
frequencies in the bivariate table are zero. The first value only 
applies for 2x2 tables. The second value for larger tables. This value 
is added to the zero frequency in the bivariate table. If 
<code>"default"</code>, the value is set depending on the <code>"mimic"</code>
option. By default, lavaan uses <code>zero.add = c(0.5. 0.0)</code>.</p>
</dd>
<dt><code>zero.keep.margins</code>:</dt><dd><p>Logical. This argument only affects 
the computation of polychoric correlations for 2x2 tables with an empty 
cell, and where a value is added to the empty cell. If <code>TRUE</code>, the 
other values of the frequency table are adjusted so that all margins are 
unaffected. If <code>"default"</code>, the value is set depending on the 
<code>"mimic"</code>. The default is <code>TRUE</code>.</p>
</dd>
<dt><code>zero.cell.warn</code>:</dt><dd><p>Logical. Only used if some observed 
endogenous variables are categorical. If <code>TRUE</code>, give a warning if 
one or more cells of a bivariate frequency table are empty.</p>
</dd>
</dl>

<p>Starting values options:
</p>

<dl>
<dt><code>start</code>:</dt><dd><p>If it is a character string, the two options are 
currently <code>"simple"</code> and <code>"Mplus"</code>. In the first case, all 
parameter values are set to zero, except the factor loadings (set to 
one), the variances of latent variables (set to 0.05), and the residual 
variances of observed variables (set to half the observed variance).
If <code>"Mplus"</code>, we use a similar scheme, but the factor loadings are
estimated using the fabin3 estimator (tsls) per factor. 
If <code>start</code> is a fitted object of class <code><a href="lavaan-class.html">lavaan</a></code>, 
the estimated values of the corresponding parameters will be extracted. 
If it is a parameter table, for example the output of the 
<code>paramaterEstimates()</code> function, the values of the <code>est</code> or 
<code>start</code> or <code>ustart</code> column (whichever is found first) will be 
extracted.</p>
</dd>
</dl>

<p>Check options:
</p>

<dl>
<dt><code>check.start</code>:</dt><dd><p>Logical. If <code>TRUE</code>,
the starting values are checked for possibly 
inconsistent values (for example values implying correlations larger 
than one). If needed, a warning is given.</p>
</dd>
<dt><code>check.gradient</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and the model
converged, a warning
is given if the optimizer decided that a (local) solution has
been found, while not all elements of the (unscaled) gradient (as 
seen by the optimizer) are (near) zero, as
they should be (the tolerance used is 0.001).</p>
</dd>
<dt><code>check.post</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and the model
converged, a check is performed after (post) fitting, to verify if 
the solution is admissable. This implies that all variances are
non-negative, and all the model-implied covariance matrices are 
positive (semi-)definite. For the latter test, we tolerate a tiny 
negative eigenvalue that is smaller than .Machine$double.eps^(3/4), 
treating it as being zero.</p>
</dd>
<dt><code>check.vcov</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and the model converged,
we check if the variance-covariance matrix of the free parameters
is positive definite. We take into account possible equality and
acitive inequality constraints. If needed, a warning is given.</p>
</dd>
</dl>

<p>Verbosity options:
</p>

<dl>
<dt><code>verbose</code>:</dt><dd><p>If <code>TRUE</code>, the function value is printed out 
during each iteration.</p>
</dd>
<dt><code>warn</code>:</dt><dd><p>If <code>TRUE</code>, some (possibly harmless) warnings 
are printed out during the iterations.</p>
</dd>
<dt><code>debug</code>:</dt><dd><p>If <code>TRUE</code>, debugging information is printed 
out.</p>
</dd>
</dl>

<p>Miscellaneous:
</p>

<dl>
<dt><code>model.type</code>:</dt><dd><p>Set the model type: possible values
are <code>"cfa"</code>, <code>"sem"</code> or <code>"growth"</code>. This may affect
how starting values are computed, and may be used to alter the terminology
used in the summary output, or the layout of path diagrams that are
based on a fitted lavaan object.</p>
</dd>
<dt><code>mimic</code>:</dt><dd><p>If <code>"Mplus"</code>, an attempt is made to mimic the 
Mplus program. If <code>"EQS"</code>, an attempt is made to mimic the EQS 
program. If <code>"default"</code>, the value is (currently) set to to 
<code>"lavaan"</code>, which is very close to <code>"Mplus"</code>.</p>
</dd>
<dt><code>representation</code>:</dt><dd><p>If <code>"LISREL"</code> the classical LISREL 
matrix representation is used to represent the model (using the all-y 
variant). No other options are available (for now).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="lavaan.html">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre>
lavOptions()
lavOptions("std.lv")
lavOptions(c("std.lv", "orthogonal"))
</pre>

<hr /><div style="text-align: center;">[Package <em>lavaan</em> version 0.6-2 <a href="00Index.html">Index</a>]</div>
</body></html>
