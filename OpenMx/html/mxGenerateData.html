<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Generate data based on an MxModel object</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for mxGenerateData {OpenMx}"><tr><td>mxGenerateData {OpenMx}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Generate data based on an MxModel object</h2>

<h3>Description</h3>

<p>This function returns a new (simulated) data set based on the model-implied distribution provided.
</p>


<h3>Usage</h3>

<pre>
mxGenerateData(model, nrows, returnModel=FALSE, use.miss = TRUE, ..., .backend=TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>model</code></td>
<td>
<p>A data.frame or MxModel object upon which the data are generated.</p>
</td></tr>
<tr valign="top"><td><code>nrows</code></td>
<td>
<p>Numeric. The number of rows of data to generate.</p>
</td></tr>
<tr valign="top"><td><code>returnModel</code></td>
<td>
<p>Logical. Return data.frames if FALSE or model
populated with new data if TRUE.</p>
</td></tr>
<tr valign="top"><td><code>use.miss</code></td>
<td>
<p>Logical. Whether to approximate the missingness
pattern of the original data.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Not used; forces remaining arguments to be specified by name.</p>
</td></tr>
<tr valign="top"><td><code>.backend</code></td>
<td>
<p>Whether to use the backend to generate data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When given a data.frame as a model, the model is assumed to be
saturated multivariate Gaussian and the expected distribution
is obtained using <a href="mxDataWLS.html">mxDataWLS</a>.  In this case, the default number of rows is assumed to be the number of rows in the original data.frame, but any other number of rows can also be requested.
</p>
<p>When given an MxModel, 
the model-implied means and covariance are extracted.  It then generates data with the same mean and covariance.  Data can be generated based on Normal (<a href="mxExpectationNormal.html">mxExpectationNormal</a>), RAM (<a href="mxExpectationRAM.html">mxExpectationRAM</a>), LISREL (<a href="mxExpectationLISREL.html">mxExpectationLISREL</a>), and state space (<a href="mxExpectationStateSpace.html">mxExpectationStateSpace</a>) models.
</p>
<p>Please note that this function samples data from the model-implied distribution(s); it does not sample from the data object in the model.  That is, this function generates new data rather than pulling data that already exist from the model.
</p>
<p>Thresholds and ordinal data are implemented by generating continuous data and then using <a href="../../base/html/cut.html">cut</a> and <a href="mxFactor.html">mxFactor</a> to break the continous data at the thresholds into an ordered factor.
</p>
<p>If the model has definition variables, then a data set must be included in the model object and the number of rows requested must match the number of rows in the model data.  In this case the means, covariance, and thresholds are reevaluated for each row of data, potentially creating a a different mean, covariance, and threshold structure for every generated row of data.
</p>
<p>For state space models (i.e. models with an <a href="mxExpectationStateSpace.html">mxExpectationStateSpace</a> or <a href="mxExpectationStateSpaceContinuousTime.html">mxExpectationStateSpaceContinuousTime</a> expectation), the data are generated based on the autoregressive structure of the model.  The rows of data in a state space model are not independent replicates of a stationary process.  Rather, they are the result of a latent (possibly non-stationary) autoregressive process.  For state space models different rows of data often correspond to different times.  As alluded to above, data generation works for discrete time state space models and hybrid continuous-discrete time state space models.  The latter have a continous process that is measured as discrete times.
</p>


<h3>Value</h3>

<p>A data.frame, list of data.frames, or model populated with the new data
(depending on the <code>returnModel</code> parameter).
Raw data is always returned even if the original model contained
covariance or some other non-raw data.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at http://openmx.ssri.psu.edu/documentation.
</p>


<h3>Examples</h3>

<pre>

#----------
# Create data based on state space model.
require(OpenMx)
nvar &lt;- 5
varnames &lt;- paste("x", 1:nvar, sep="")
ssModel &lt;- mxModel(model="State Space Manual Example",
    mxMatrix("Full", 1, 1, TRUE, .3, name="A"),
    mxMatrix("Zero", 1, 1, name="B"),
    mxMatrix("Full", nvar, 1, TRUE, .6, name="C", dimnames=list(varnames, "F1")),
    mxMatrix("Zero", nvar, 1, name="D"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="Q"),
    mxMatrix("Diag", nvar, nvar, TRUE, .2, name="R"),
    mxMatrix("Zero", 1, 1, name="x0"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="P0"),
    mxMatrix("Zero", 1, 1, name="u"),
    mxExpectationStateSpace("A", "B", "C", "D", "Q", "R", "x0", "P0", "u"),
    mxFitFunctionML()
)

ssData &lt;- mxGenerateData(ssModel, 200) # 200 time points

# Add simulated data to model
ssModel &lt;- mxModel(ssModel, mxData(ssData, 'raw'))

# Fit model to simulated data
ssRun &lt;- mxRun(ssModel)

# Compare parameters estimated from random data to
#  their true generating values
cbind(Rand = omxGetParameters(ssRun), Gen = omxGetParameters(ssModel))
# Note the parameters should be "close" (up to sampling error)
# to the generating values


#----------
require(OpenMx)
manifests &lt;- paste("x", 1:5, sep="")
latents &lt;- c("G")
factorModel &lt;- mxModel("One Factor",
      type="RAM",
      manifestVars = manifests,
      latentVars = latents,
      mxPath(from=latents, to=manifests, values=.8),
      mxPath(from=manifests, arrows=2, values=.2),
      mxPath(from=latents, arrows=2,
            free=FALSE, values=1.0),
      mxPath(from = 'one', to = manifests))

factorData &lt;- mxGenerateData(factorModel, 100)

factorModel &lt;- mxModel(factorModel,
                       mxData(observed=cov(factorData), type="cov",
                              numObs=nrow(factorData),
                              means = colMeans(factorData)))
factorRun &lt;- mxRun(factorModel)
cbind(Rand=omxGetParameters(factorRun), Gen=omxGetParameters(factorModel))


</pre>

<hr /><div style="text-align: center;">[Package <em>OpenMx</em> version 2.10.0 <a href="00Index.html">Index</a>]</div>
</body></html>
