<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Create MxFitFunctionMultigroup object</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for mxFitFunctionMultigroup {OpenMx}"><tr><td>mxFitFunctionMultigroup {OpenMx}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Create MxFitFunctionMultigroup object</h2>

<h3>Description</h3>

<p>The fit function used to fit a multiple group model</p>


<h3>Usage</h3>

<pre>
mxFitFunctionMultigroup(groups, ..., verbose = 0L)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>groups</code></td>
<td>
<p>vector of fit function names (strings)</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Not used. Forces subsequent arguments to be specified by name.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>the level of debugging output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxFitFunctionMultigroup creates a fit function consisting of the sum of the fit
statistics from a list of submodels provided.  Thus, it aggregates fit statistics from multiple submodels.
</p>
<p>This is conceptually similar to creating an <a href="mxAlgebra.html">mxAlgebra</a> consisting of the sum of 
the subModel objectives and also creating an <a href="mxFitFunctionAlgebra.html">mxFitFunctionAlgebra</a> to optimize the
model based on this aggregate value.
</p>
<p>This call to mxFitFunctionMultigroup:
</p>
<p><code>mxFitFunctionMultigroup(c("model1", "model2"))</code>
</p>
<p>then, is almost equivalent to the following pair of statements:
</p>
<p><code>mxAlgebra(model1.objective + model2.objective, name="myAlgebra")</code>
</p>
<p><code>mxFitFunctionAlgebra("myAlgebra")</code>
</p>
<p>The preferred method of specifying such a fit function is with this multigroup fit function, not the algebra fit function.
</p>
<p>In addition to being more compact and readable, using mxFitFunctionMultigroup has
additional side effects which are valuable for multi-group modeling.
</p>
<p>Firstly, it aggregates analytic derivative calculations. Secondly, it allows <code><a href="omxSaturatedModel.html">mxRefModels</a></code> 
to compute saturated models for raw data, as this function can learn which are the constituent submodels.  Thirdly, it allows <code><a href="mxCheckIdentification.html">mxCheckIdentification</a></code> to evaluate the local identification of the multigroup model.
</p>
<p>Note: You can refer to the algebra generated by mxFitFunctionMultigroup when used in a group &quot;modelName&quot;
as:
</p>
<p><code>modelName.fitfunction</code>
</p>


<h3>See Also</h3>

<p>Other fit functions:
<code><a href="mxFitFunctionML.html">mxFitFunctionML</a></code>, 
<code><a href="mxFitFunctionWLS.html">mxFitFunctionWLS</a></code>, <code><a href="mxFitFunctionAlgebra.html">mxFitFunctionAlgebra</a></code>, 
<code><a href="mxFitFunctionGREML.html">mxFitFunctionGREML</a></code>, <code><a href="mxFitFunctionR.html">mxFitFunctionR</a></code>, 
<code><a href="mxFitFunctionRow.html">mxFitFunctionRow</a></code>
</p>
<p>More information about the OpenMx package may be found <a href="OpenMx.html">here</a>. 
</p>


<h3>Examples</h3>

<pre>
#------------------------------------------------
# Brief non-running example
require("OpenMx")
mxFitFunctionMultigroup(c("model1", "model2")) # names of sub-models to be jointly optimised


#------------------------------------------------
# Longer, fully featured, running example
# 
# 
# Create and fit a model using mxMatrix, mxExpectationRAM, mxFitFunctionML,
# and mxFitFunctionMultigroup.
# The model is multiple group regression.
# Only the residual variances are allowed to differ across groups.


library(OpenMx)

# Simulate some data

# Group 1
N1=100
x=rnorm(N1, mean=0, sd=1)
y= 0.5*x + rnorm(N1, mean=0, sd=1)
ds1 &lt;- data.frame(x, y)
dsNames &lt;- names(ds1)

# Group 2
N2=150
x=rnorm(N2, mean=0, sd=1)
y= 0.5*x + rnorm(N2, mean=0, sd=sqrt(1.5))
ds2 &lt;- data.frame(x, y)


# Define the matrices
M &lt;- mxMatrix(type = "Full", nrow = 1, ncol = 2, values=0,
              free=TRUE, labels=c("Mx", "My"), name = "M")
S1 &lt;- mxMatrix(type = "Diag", nrow = 2, ncol = 2, values=1, 
              free=TRUE, labels=c("Vx", "ResidVy1"), name = "S")
S2 &lt;- mxMatrix(type = "Diag", nrow = 2, ncol = 2, values=1, 
              free=TRUE, labels=c("Vx", "ResidVy2"), name = "S")
A &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0), 
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA),
              name = "A")
I &lt;- mxMatrix(type="Iden", nrow=2, ncol=2, name="I")


# Define the expectation
expect &lt;- mxExpectationRAM('A', 'S', 'I', 'M', dimnames=dsNames)


# Choose a fit function
fitFunction &lt;- mxFitFunctionML(rowDiagnostics=TRUE)
# also return row likelihoods, even though the fit function
#  value is still 1x1

# Multiple groupd fit function sums the model likelihoods
#  from its component models
mgFitFun &lt;- mxFitFunctionMultigroup(c('g1model', 'g2model'))


# Define the models
m1 &lt;- mxModel(model="g1model", M, S1, A, I, expect, fitFunction, 
              mxData(observed=cov(ds1), type="cov", numObs=nrow(ds1),
                     means=colMeans(ds1)))
m2 &lt;- mxModel(model="g2model", M, S2, A, I, expect, fitFunction, 
              mxData(observed=cov(ds2), type="cov", numObs=nrow(ds2),
                     means=colMeans(ds2)))
mg &lt;- mxModel(model='multipleGroup', m1, m2, mgFitFun)

# Fit the model and print a summary

mgOut &lt;- mxRun(mg)

# Look at summary of model
summary(mgOut)

# Examine fit function results
fitResOnly &lt;- mxEval(fitfunction, mgOut)
( g1Fit &lt;- mxEval(g1model.fitfunction, mgOut) )
( g2Fit &lt;- mxEval(g2model.fitfunction, mgOut) )


</pre>

<hr /><div style="text-align: center;">[Package <em>OpenMx</em> version 2.10.0 <a href="00Index.html">Index</a>]</div>
</body></html>
