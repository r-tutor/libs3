<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Create MxAlgebra Object</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for mxAlgebra {OpenMx}"><tr><td>mxAlgebra {OpenMx}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Create MxAlgebra Object</h2>

<h3>Description</h3>

<p>This function creates a new <a href="MxAlgebra-class.html">MxAlgebra</a> object.
</p>


<h3>Usage</h3>

<pre>
mxAlgebra(expression, name = NA, dimnames = NA, ..., fixed = FALSE,
          joinKey=as.character(NA), joinModel=as.character(NA), verbose=0L)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>expression</code></td>
<td>
<p>An R expression of OpenMx-supported matrix operators and matrix functions.</p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>An optional character string indicating the name of the object.</p>
</td></tr>
<tr valign="top"><td><code>dimnames</code></td>
<td>
<p>list. The dimnames attribute for the algebra: a list
of length 2 giving the row and column names respectively. An empty
list is treated as NULL, and a list of length one as row names. The
list can be named, and the list names will be used as names for the
dimensions.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Not used.  Forces argument &lsquo;fixed&rsquo; to be specified by name.</p>
</td></tr>
<tr valign="top"><td><code>fixed</code></td>
<td>
<p>If TRUE, this algebra will not be recomputed
automatically when things it depends on change. <a href="mxComputeOnce.html">mxComputeOnce</a>
can be used to force it to recompute.</p>
</td></tr>
<tr valign="top"><td><code>joinKey</code></td>
<td>
<p>The name of the column in current model's raw data that
is used as a foreign key to match against the primary key in
joinModel's raw data.</p>
</td></tr>
<tr valign="top"><td><code>joinModel</code></td>
<td>
<p>The name of the model that this matrix joins against.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>For values greater than zero, enable runtime diagnostics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxAlgebra function is used to create algebraic expressions that operate on one or more 
<a href="MxMatrix-class.html">MxMatrix</a> objects. To evaluate an <a href="MxAlgebra-class.html">MxAlgebra</a> object, 
it must be placed in an <a href="MxModel-class.html">MxModel</a> object, along with all referenced <code>MxMatrix</code> 
objects and the <code>mxFitFunctionAlgebra</code> function. 
The <code>mxFitFunctionAlgebra</code> function must reference by name the <code>MxAlgebra</code> object to be evaluated.
</p>
<p>Note that, if the result for an <a href="MxAlgebra-class.html">MxAlgebra</a> depends upon one or more &quot;definition variables&quot; (see <code><a href="mxMatrix.html">mxMatrix</a>()</code>), then the value returned after the call to <code><a href="mxRun.html">mxRun</a>()</code> will be computed using the values of those definition variables in the first (i.e., first before any automated sorting is done) row of the raw dataset.
</p>
<p>The following operators and functions are supported in mxAlgebra:
</p>
<p>Operators
</p>

<dl>
<dt><code>solve()</code></dt><dd><p>Inversion</p>
</dd>
<dt><code>t()</code></dt><dd><p>Transposition</p>
</dd>
<dt><code>^</code></dt><dd><p>Elementwise powering</p>
</dd>
<dt><code>%^%</code></dt><dd><p>Kronecker powering</p>
</dd>
<dt><code>+</code></dt><dd><p>Addition</p>
</dd>
<dt><code>-</code></dt><dd><p>Subtraction</p>
</dd>
<dt><code>%*%</code></dt><dd><p>Matrix Multiplication</p>
</dd>
<dt><code>*</code></dt><dd><p>Elementwise product</p>
</dd>
<dt><code>/</code></dt><dd><p>Elementwise division</p>
</dd>
<dt><code>%x%</code></dt><dd><p>Kronecker product</p>
</dd>
<dt><code>%&amp;%</code></dt><dd><p>Quadratic product: pre- and post-multiply B by A and its transpose t(A), i.e: A <code>%&amp;%</code> B ==  A <code>%*%</code> B <code>%*%</code> t(A)</p>
</dd>
</dl>

<p>Functions
</p>

<dl>
<dt><code>cov2cor</code></dt><dd><p>Convert covariance matrix to correlation matrix</p>
</dd>
<dt><code>chol</code></dt><dd><p>Cholesky Decomposition</p>
</dd>
<dt><code>cbind</code></dt><dd><p>Horizontal adhesion</p>
</dd>
<dt><code>rbind</code></dt><dd><p>Vertical adhesion</p>
</dd>
<dt><code>colSums</code></dt><dd><p>Matrix column sums as a column vector</p>
</dd>
<dt><code>rowSums</code></dt><dd><p>Matrix row sums as a column vector</p>
</dd>
<dt><code>det</code></dt><dd><p>Determinant</p>
</dd>
<dt><code>tr</code></dt><dd><p>Trace</p>
</dd>
<dt><code>sum</code></dt><dd><p>Sum</p>
</dd>
<dt><code>mean</code></dt><dd><p>Arithmetic mean</p>
</dd>
<dt><code>prod</code></dt><dd><p>Product</p>
</dd>
<dt><code>max</code></dt><dd><p>Maximum</p>
</dd>
<dt><code>min</code></dt><dd><p>Min</p>
</dd>
<dt><code>abs</code></dt><dd><p>Absolute value</p>
</dd>
<dt><code>sin</code></dt><dd><p>Sine</p>
</dd>
<dt><code>sinh</code></dt><dd><p>Hyperbolic sine</p>
</dd>
<dt><code>asin</code></dt><dd><p>Arcsine</p>
</dd>
<dt><code>asinh</code></dt><dd><p>Inverse hyperbolic sine</p>
</dd>
<dt><code>cos</code></dt><dd><p>Cosine</p>
</dd>
<dt><code>cosh</code></dt><dd><p>Hyperbolic cosine</p>
</dd>
<dt><code>acos</code></dt><dd><p>Arccosine</p>
</dd>
<dt><code>acosh</code></dt><dd><p>Inverse hyperbolic cosine</p>
</dd>
<dt><code>tan</code></dt><dd><p>Tangent</p>
</dd>
<dt><code>tanh</code></dt><dd><p>Hyperbolic tangent</p>
</dd>
<dt><code>atan</code></dt><dd><p>Arctangent</p>
</dd>
<dt><code>atanh</code></dt><dd><p>Inverse hyperbolic tangent</p>
</dd>
<dt><code>exp</code></dt><dd><p>Exponent</p>
</dd>
<dt><code>log</code></dt><dd><p>Natural Logarithm</p>
</dd>
<dt><code>mxRobustLog</code></dt><dd><p>Robust natural logarithm</p>
</dd>
<dt><code>sqrt</code></dt><dd><p>Square root</p>
</dd>
<dt><code>p2z</code></dt><dd><p><em>Standard</em>-normal quantile</p>
</dd>
<dt><code>logp2z</code></dt><dd><p><em>Standard</em>-normal quantile from log probabilities</p>
</dd>
<dt><code>lgamma</code></dt><dd><p>Log-gamma function</p>
</dd>
<dt><code>lgamma1p</code></dt><dd><p>Compute log(gamma(x+1)) accurately for small x</p>
</dd>
<dt><code><a href="eigenvec.html">eigenval</a></code></dt><dd><p>Eigenvalues of a square matrix. Usage: eigenval(x); eigenvec(x); ieigenval(x); ieigenvec(x)</p>
</dd>
<dt><code><a href="rvectorize.html">rvectorize</a></code></dt><dd><p>Vectorize by row</p>
</dd>
<dt><code><a href="cvectorize.html">cvectorize</a></code></dt><dd><p>Vectorize by column</p>
</dd>
<dt><code><a href="vech.html">vech</a></code></dt><dd><p>Half-vectorization</p>
</dd>
<dt><code><a href="vechs.html">vechs</a></code></dt><dd><p>Strict half-vectorization</p>
</dd>
<dt><code><a href="vech2full.html">vech2full</a></code></dt><dd><p>Inverse half-vectorization</p>
</dd>
<dt><code><a href="vechs2full.html">vechs2full</a></code></dt><dd><p>Inverse strict half-vectorization</p>
</dd>
<dt><code><a href="vec2diag.html">vec2diag</a></code></dt><dd><p>Create matrix from a diagonal vector (similar to <a href="../../base/html/diag.html">diag</a>) </p>
</dd>
<dt><code><a href="diag2vec.html">diag2vec</a></code></dt><dd><p>Extract diagonal from matrix (similar to <a href="../../base/html/diag.html">diag</a>) </p>
</dd>
<dt><code><a href="expm.html">expm</a></code></dt><dd><p>Matrix Exponential</p>
</dd>
<dt><code><a href="logm.html">logm</a></code></dt><dd><p>Matrix Logarithm</p>
</dd>
<dt><code><a href="expm.html">omxExponential</a></code></dt><dd><p>Matrix Exponential</p>
</dd>
<dt><code><a href="omxMnor.html">omxMnor</a></code></dt><dd><p>Multivariate Normal Integration</p>
</dd>
<dt><code><a href="omxAllInt.html">omxAllInt</a></code></dt><dd><p>All cells Multivariate Normal Integration</p>
</dd>
<dt><code><a href="omxLogical.html">omxNot</a></code></dt><dd><p>Perform unary negation on a matrix</p>
</dd>
<dt><code><a href="omxLogical.html">omxAnd</a></code></dt><dd><p>Perform binary and on two matrices</p>
</dd>
<dt><code><a href="omxLogical.html">omxOr</a></code></dt><dd><p>Perform binary or on two matrices</p>
</dd>
<dt><code><a href="omxLogical.html">omxGreaterThan</a></code></dt><dd><p>Perform binary greater on two matrices</p>
</dd>
<dt><code><a href="omxLogical.html">omxLessThan</a></code></dt><dd><p>Perform binary less than on two matrices</p>
</dd>
<dt><code><a href="omxLogical.html">omxApproxEquals</a></code></dt><dd><p>Perform binary equals to (within a specified epsilon) on two matrices</p>
</dd>
<dt><code><a href="omxSelectRowsAndCols.html">omxSelectRows</a></code></dt><dd><p>Filter rows from a matrix</p>
</dd>
<dt><code><a href="omxSelectRowsAndCols.html">omxSelectCols</a></code></dt><dd><p>Filter columns from a matrix</p>
</dd>
<dt><code><a href="omxSelectRowsAndCols.html">omxSelectRowsAndCols</a></code></dt><dd><p>Filter rows and columns from a matrix</p>
</dd>
<dt><code><a href="mxEvaluateOnGrid.html">mxEvaluateOnGrid</a></code></dt><dd><p>Evaluate
an algebra on an abscissa grid and collect column results</p>
</dd>
</dl>

<p><code>mxRobustLog</code> is the same as <code>log</code> except that it returns -745
instead of -Inf for an argument of 0. The value -745 is less than
log(4.94066e-324), a good approximation of negative infinity because the
log of any number represented as a double will be of smaller absolute
magnitude.
</p>
<p>There are also several multiargument functions usable in MxAlgebras, which apply themselves elementwise to the matrix provided as their first argument.  These functions have slightly different usage from their <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> counterparts.  Their result is always a matrix with the same dimensions as that provided for their first argument.  Values must be provided for ALL arguments of these functions, in order.  Provide zeroes as logical values of <code>FALSE</code>, and non-zero numerical values as logical values of <code>TRUE</code>.  For most of these functions, OpenMx cycles over values of arguments other than the first, by column (i.e., in column-major order), to the length of the first argument.  Notable exceptions are the <code>log</code>, <code>log.p</code>, and <code>lower.tail</code> arguments to probability-distribution-related functions, for which only the [1,1] element is used.  It is recommended that all arguments after the first be either (1) scalars, or (2) matrices with the same dimensions as the first argument.
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: center;">
Function </td><td style="text-align: center;"> Arguments </td><td style="text-align: left;"> Notes </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>besselI</code> &amp; <code>besselK</code> </td><td style="text-align: center;"> <code>x,nu,expon.scaled</code> </td><td style="text-align: left;"> Note that OpenMx <em>does</em> cycle over the elements of <code>expon.scaled</code>. </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>besselJ</code> &amp; <code>besselY</code> </td><td style="text-align: center;"> <code>x,nu</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dbeta</code> </td><td style="text-align: center;"> <code>x,shape1,shape2,ncp,log</code> </td><td style="text-align: left;"> The algorithm for the non-central beta distribution is used for non-negative values of <code>ncp</code>.  Negative <code>ncp</code> values are ignored, and the algorithm for the central beta distribution is used. </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>pbeta</code> </td><td style="text-align: center;"> <code>q,shape1,shape2,ncp,lower.tail,log.p</code> </td><td style="text-align: left;"> Values of <code>ncp</code> are handled as with <code>dbeta()</code>.</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dbinom</code> </td><td style="text-align: center;"> <code>x,size,prob,log</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>pbinom</code> </td><td style="text-align: center;"> <code>q,size,prob,lower.tail,log.p</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dcauchy</code> </td><td style="text-align: center;"> <code>x,location,scale,log</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>pcauchy</code> </td><td style="text-align: center;"> <code>q,location,scale,lower.tail,log.p</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dchisq</code> </td><td style="text-align: center;"> <code>x,df,ncp,log</code> </td><td style="text-align: left;">  The algorithm for the non-central chi-square distribution is used for non-negative values of <code>ncp</code>.  Negative <code>ncp</code> values are ignored, and the algorithm for the central chi-square distribution is used. </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>pchisq</code> </td><td style="text-align: center;"> <code>q,df,ncp,lower.tail,log.p</code> </td><td style="text-align: left;"> Values of <code>ncp</code> are handled as with <code>dchisq()</code>. </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>omxDnbinom</code> </td><td style="text-align: center;"> <code>x,size,prob,mu,log</code> </td><td style="text-align: left;"> Exactly one of arguments <code>size</code>, <code>prob</code>, and <code>mu</code> should be negative, and therefore ignored.  Otherwise, <code>mu</code> is ignored, possibly with a warning, and the values of <code>size</code> and <code>prob</code> are used, irrespective of whether they are in the parameter space.  If only <code>prob</code> is negative, the algorithm for the alternative <code>size</code>-<code>mu</code> parameterization is used.  If <code>size</code> is negative, a value for <code>size</code> is calculated as <code>mu*prob/(1-prob)</code>, and the algorithm for the <code>size</code>-<code>prob</code> parameterization is used (note that this approach is ill-advised when <code>prob</code> is very close to 0 or 1).</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>omxPnbinom</code> </td><td style="text-align: center;"> <code>q,size,prob,mu,lower.tail,log.p</code> </td><td style="text-align: left;"> Arguments are handled as with <code>omxDnbinom()</code>.</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dpois</code> </td><td style="text-align: center;"> <code>x,lambda,log</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>ppois</code> </td><td style="text-align: center;"> <code>q,lambda,lower.tail,log.p</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns a new <a href="MxAlgebra-class.html">MxAlgebra</a> object.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at http://openmx.ssri.psu.edu/documentation.
</p>


<h3>See Also</h3>

<p><a href="MxAlgebra-class.html">MxAlgebra</a> for the S4 class created by mxAlgebra. <a href="mxFitFunctionAlgebra.html">mxFitFunctionAlgebra</a> for an objective function which takes an  MxAlgebra or MxMatrix object as the function to be minimized. 
<a href="MxMatrix-class.html">MxMatrix</a> and <a href="mxMatrix.html">mxMatrix</a> for objects which may be entered in the <code>expression</code> argument and the function that creates them. More information about the OpenMx package may be found <a href="OpenMx.html">here</a>. 
</p>


<h3>Examples</h3>

<pre>

A &lt;- mxMatrix("Full", nrow = 3, ncol = 3, values=2, name = "A")

# Simple example: algebra B simply evaluates to the matrix A
B &lt;- mxAlgebra(A, name = "B")

# Compute A + B
C &lt;- mxAlgebra(A + B, name = "C")

# Compute sin(C)
D &lt;- mxAlgebra(sin(C), name = "D")

# Make a model and evaluate the mxAlgebra object 'D'
A &lt;- mxMatrix("Full", nrow = 3, ncol = 3, values=2, name = "A")
model &lt;- mxModel(model="AlgebraExample", A, B, C, D )
fit   &lt;- mxRun(model)
mxEval(D, fit)


# Numbers in mxAlgebras are upgraded to 1x1 matrices
# Example of Kronecker powering (%^%) and multiplication (%*%)
A  &lt;- mxMatrix(type="Full", nrow=3, ncol=3, value=c(1:9), name="A")
m1 &lt;- mxModel(model="kron", A, mxAlgebra(A %^% 2, name="KroneckerPower"))
mxRun(m1)$KroneckerPower

# Running kron 
# mxAlgebra 'KroneckerPower' 
# $formula:  A %^% 2 
# $result:
#      [,1] [,2] [,3]
# [1,]    1   16   49
# [2,]    4   25   64
# [3,]    9   36   81

</pre>

<hr /><div style="text-align: center;">[Package <em>OpenMx</em> version 2.10.0 <a href="00Index.html">Index</a>]</div>
</body></html>
