<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction to labelled</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{labelled}
-->

<h1>Introduction to labelled</h1>

<p>The purpose of the <strong>labelled</strong> package is to provide functions to manipulate
metadata as variable labels, value labels and defined missing values
using the <code>labelled</code> class and the <code>label</code> attribute introduced in <code>haven</code> package.</p>

<h2>Variable labels</h2>

<p>A variable label could be specified for any vector using <code>var_label</code>.</p>

<pre><code class="r">library(labelled)

var_label(iris$Sepal.Length) &lt;- &quot;Length of sepal&quot;
</code></pre>

<p>It&#39;s possible to add a variable label to several columns of a data frame using a named list.</p>

<pre><code class="r">var_label(iris) &lt;- list(Petal.Length = &quot;Length of petal&quot;, Petal.Width = &quot;Width of Petal&quot;)
</code></pre>

<p>To get the variable label, simply call <code>var_label</code>.</p>

<pre><code class="r">var_label(iris$Petal.Width)
</code></pre>

<pre><code>## [1] &quot;Width of Petal&quot;
</code></pre>

<pre><code class="r">var_label(iris)
</code></pre>

<pre><code>## $Sepal.Length
## [1] &quot;Length of sepal&quot;
## 
## $Sepal.Width
## NULL
## 
## $Petal.Length
## [1] &quot;Length of petal&quot;
## 
## $Petal.Width
## [1] &quot;Width of Petal&quot;
## 
## $Species
## NULL
</code></pre>

<p>To remove a variable label, use <code>NULL</code>.</p>

<pre><code class="r">var_label(iris$Sepal.Length) &lt;- NULL
</code></pre>

<p>In <strong>RStudio</strong>, variable labels will be displayed in data viewer.</p>

<pre><code class="r">View(iris)
</code></pre>

<h2>Value labels</h2>

<p>The first way to create a labelled vector is to use the <code>labelled</code> function.
It&#39;s not mandatory to provide a label for each value observed in your vector.
You can also provide a label for values not observed.</p>

<pre><code class="r">v &lt;- labelled(c(1,2,2,2,3,9,1,3,2,NA), c(yes = 1, no = 3, &quot;don&#39;t know&quot; = 8, refused = 9))
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value      label
##      1        yes
##      3         no
##      8 don&#39;t know
##      9    refused
</code></pre>

<p>Use <code>val_labels</code> to get all value labels and <code>val_label</code> to get the value label associated 
with a specific value.</p>

<pre><code class="r">val_labels(v)
</code></pre>

<pre><code>##        yes         no don&#39;t know    refused 
##          1          3          8          9
</code></pre>

<pre><code class="r">val_label(v, 8)
</code></pre>

<pre><code>## [1] &quot;don&#39;t know&quot;
</code></pre>

<p><code>val_labels</code> could also be used to modify all the value labels attached to a vector, 
while <code>val_label</code> will update only one specific value label.</p>

<pre><code class="r">val_labels(v) &lt;- c(yes = 1, nno = 3, bug = 5)
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value label
##      1   yes
##      3   nno
##      5   bug
</code></pre>

<pre><code class="r">val_label(v, 3) &lt;- &quot;no&quot;
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value label
##      1   yes
##      3    no
##      5   bug
</code></pre>

<p>With <code>val_label</code>, you can also add or remove specific value labels.</p>

<pre><code class="r">val_label(v, 2) &lt;- &quot;maybe&quot;
val_label(v, 5) &lt;- NULL
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value label
##      1   yes
##      3    no
##      2 maybe
</code></pre>

<p>To remove all value labels, use <code>val_labels</code> and <code>NULL</code>. The <code>labelled</code> class will also be removed.</p>

<pre><code class="r">val_labels(v) &lt;- NULL
v
</code></pre>

<pre><code>##  [1]  1  2  2  2  3  9  1  3  2 NA
</code></pre>

<p>Adding a value label to a non labelled vector will apply <code>labelled</code> class to it.</p>

<pre><code class="r">val_label(v, 1) &lt;- &quot;yes&quot;
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value label
##      1   yes
</code></pre>

<p>Note that applying <code>val_labels</code> to a factor will have no effect!</p>

<pre><code class="r">f &lt;- factor(1:3)
f
</code></pre>

<pre><code>## [1] 1 2 3
## Levels: 1 2 3
</code></pre>

<pre><code class="r">val_labels(f) &lt;- c(yes = 1, no = 3)
f
</code></pre>

<pre><code>## [1] 1 2 3
## Levels: 1 2 3
</code></pre>

<p>You could also apply value labels to several columns of a data frame.</p>

<pre><code class="r">df &lt;- data.frame(v1 = 1:3, v2 = c(2, 3, 1), v3 = 3:1)

val_label(df, 1) &lt;- &quot;yes&quot;
val_label(df[, c(&quot;v1&quot;, &quot;v3&quot;)], 2) &lt;- &quot;maybe&quot;
val_label(df[, c(&quot;v2&quot;, &quot;v3&quot;)], 3) &lt;- &quot;no&quot;
val_labels(df)
</code></pre>

<pre><code>## $v1
##   yes maybe 
##     1     2 
## 
## $v2
## yes  no 
##   1   3 
## 
## $v3
##   yes maybe    no 
##     1     2     3
</code></pre>

<pre><code class="r">val_labels(df[, c(&quot;v1&quot;, &quot;v3&quot;)]) &lt;- c(YES = 1, MAYBE = 2, NO = 3)
val_labels(df)
</code></pre>

<pre><code>## $v1
##   YES MAYBE    NO 
##     1     2     3 
## 
## $v2
## yes  no 
##   1   3 
## 
## $v3
##   YES MAYBE    NO 
##     1     2     3
</code></pre>

<pre><code class="r">val_labels(df) &lt;- NULL
val_labels(df)
</code></pre>

<pre><code>## $v1
## NULL
## 
## $v2
## NULL
## 
## $v3
## NULL
</code></pre>

<pre><code class="r">val_labels(df) &lt;- list(v1 = c(yes = 1, no = 3), v2 = c(a = 1, b = 2, c = 3))
val_labels(df)
</code></pre>

<pre><code>## $v1
## yes  no 
##   1   3 
## 
## $v2
## a b c 
## 1 2 3 
## 
## $v3
## NULL
</code></pre>

<h2>Sorting value labels</h2>

<p>Value labels are sorted by default in the order they have been created.</p>

<pre><code class="r">v &lt;- c(1,2,2,2,3,9,1,3,2,NA)
val_label(v, 1) &lt;- &quot;yes&quot;
val_label(v, 3) &lt;- &quot;no&quot;
val_label(v, 9) &lt;- &quot;refused&quot;
val_label(v, 2) &lt;- &quot;maybe&quot;
val_label(v, 8) &lt;- &quot;don&#39;t know&quot;
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value      label
##      1        yes
##      3         no
##      9    refused
##      2      maybe
##      8 don&#39;t know
</code></pre>

<p>It could be useful to reorder the value labels according to their attached values.</p>

<pre><code class="r">sort_val_labels(v)
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value      label
##      1        yes
##      2      maybe
##      3         no
##      8 don&#39;t know
##      9    refused
</code></pre>

<pre><code class="r">sort_val_labels(v, decreasing = TRUE)
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value      label
##      9    refused
##      8 don&#39;t know
##      3         no
##      2      maybe
##      1        yes
</code></pre>

<p>If you prefer, you can also sort them according to the labels.</p>

<pre><code class="r">sort_val_labels(v, according_to = &quot;l&quot;)
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value      label
##      8 don&#39;t know
##      2      maybe
##      3         no
##      9    refused
##      1        yes
</code></pre>

<h2>User defined missing values (SPSS&#39;s style)</h2>

<p><code>haven</code> (&gt;= 1.0.0) introduced an additional <code>labelled_spss</code> class to deal with user defined missing values. In such case, additional atributes will be used to indicate with values should be considered as missing, but such values will not be stored as internal <code>NA</code> values. You should note that most R function will not take this information into account. Therefore, you will have to convert missing values into <code>NA</code> if required before analysis. These defined missing values could co-exist with internal <code>NA</code> values.</p>

<p>It is possible to manipulate this missing values with <code>na_values()</code> and <code>na_range()</code>. </p>

<pre><code class="r">v &lt;- labelled(c(1,2,2,2,3,9,1,3,2,NA), c(yes = 1, no = 3, &quot;don&#39;t know&quot; = 9))
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value      label
##      1        yes
##      3         no
##      9 don&#39;t know
</code></pre>

<pre><code class="r">na_values(v) &lt;- 9
na_values(v)
</code></pre>

<pre><code>## [1] 9
</code></pre>

<pre><code class="r">v
</code></pre>

<pre><code>## &lt;Labelled SPSS double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## Missing values: 9
## 
## Labels:
##  value      label
##      1        yes
##      3         no
##      9 don&#39;t know
</code></pre>

<pre><code class="r">na_values(v) &lt;- NULL
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value      label
##      1        yes
##      3         no
##      9 don&#39;t know
</code></pre>

<pre><code class="r">na_range(v) &lt;- c(5, Inf)
na_range(v)
</code></pre>

<pre><code>## [1]   5 Inf
</code></pre>

<pre><code class="r">v
</code></pre>

<pre><code>## &lt;Labelled SPSS double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## Missing range:  [5, Inf]
## 
## Labels:
##  value      label
##      1        yes
##      3         no
##      9 don&#39;t know
</code></pre>

<p>It is <strong>mandatory</strong> to defined at least one value label before defining missing values. Therefore, the following example will fail.</p>

<pre><code class="r">x &lt;- c(1, 2, 2, 9)
na_values(x) &lt;- 9
</code></pre>

<p>You shoudl try:</p>

<pre><code class="r">x &lt;- c(1, 2, 2, 9)
val_labels(x) &lt;- c(yes = 1, no = 2)
na_values(x) &lt;- 9
x
</code></pre>

<pre><code>## &lt;Labelled SPSS double&gt;
## [1] 1 2 2 9
## Missing values: 9
## 
## Labels:
##  value label
##      1   yes
##      2    no
</code></pre>

<p>To convert user defined missing values into <code>NA</code>, simply use <code>user_na_to_na()</code>.</p>

<pre><code class="r">v &lt;- labelled_spss(1:10, c(Good = 1, Bad = 8), na_values = c(9, 10))
v
</code></pre>

<pre><code>## &lt;Labelled SPSS integer&gt;
##  [1]  1  2  3  4  5  6  7  8  9 10
## Missing values: 9, 10
## 
## Labels:
##  value label
##      1  Good
##      8   Bad
</code></pre>

<pre><code class="r">v2 &lt;- user_na_to_na(v)
v2
</code></pre>

<pre><code>## &lt;Labelled integer&gt;
##  [1]  1  2  3  4  5  6  7  8 NA NA
## 
## Labels:
##  value label
##      1  Good
##      8   Bad
</code></pre>

<p>You can also remove user missing values definition without converting these values to <code>NA</code>.</p>

<pre><code class="r">v &lt;- labelled_spss(1:10, c(Good = 1, Bad = 8), na_values = c(9, 10))
v
</code></pre>

<pre><code>## &lt;Labelled SPSS integer&gt;
##  [1]  1  2  3  4  5  6  7  8  9 10
## Missing values: 9, 10
## 
## Labels:
##  value label
##      1  Good
##      8   Bad
</code></pre>

<pre><code class="r">v2 &lt;- remove_user_na(v)
</code></pre>

<pre><code>## Some user defined missing values have been removed but not converted to NA.
</code></pre>

<pre><code class="r">v2
</code></pre>

<pre><code>## &lt;Labelled integer&gt;
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## Labels:
##  value label
##      1  Good
##      8   Bad
</code></pre>

<p>or</p>

<pre><code class="r">v &lt;- labelled_spss(1:10, c(Good = 1, Bad = 8), na_values = c(9, 10))
v
</code></pre>

<pre><code>## &lt;Labelled SPSS integer&gt;
##  [1]  1  2  3  4  5  6  7  8  9 10
## Missing values: 9, 10
## 
## Labels:
##  value label
##      1  Good
##      8   Bad
</code></pre>

<pre><code class="r">na_values(v) &lt;- NULL
v
</code></pre>

<pre><code>## &lt;Labelled integer&gt;
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## Labels:
##  value label
##      1  Good
##      8   Bad
</code></pre>

<h2>Other conversion to NA</h2>

<p>In some cases, values who don&#39;t have an attached value label could be considered as missing.
<code>nolabel_to_na</code> will convert them to <code>NA</code>.</p>

<pre><code class="r">v &lt;- labelled(c(1,2,2,2,3,9,1,3,2,NA), c(yes = 1, maybe = 2, no = 3))
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value label
##      1   yes
##      2 maybe
##      3    no
</code></pre>

<pre><code class="r">nolabel_to_na(v)
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3 NA  1  3  2 NA
## 
## Labels:
##  value label
##      1   yes
##      2 maybe
##      3    no
</code></pre>

<p>In other cases, a value label is attached only to specific values that corresponds to 
a missing value. For example:</p>

<pre><code class="r">size &lt;- labelled(c(1.88, 1.62, 1.78, 99, 1.91), c(&quot;not measured&quot; = 99))
size
</code></pre>

<pre><code>## &lt;Labelled double&gt;
## [1]  1.88  1.62  1.78 99.00  1.91
## 
## Labels:
##  value        label
##     99 not measured
</code></pre>

<p>In such cases, <code>val_labels_to_na</code> could be appropriate.</p>

<pre><code class="r">val_labels_to_na(size)
</code></pre>

<pre><code>## [1] 1.88 1.62 1.78   NA 1.91
</code></pre>

<p>These two functions could also be applied to an overall data frame. 
Only labelled vectors will be impacted.</p>

<h2>Converting to factor</h2>

<p>A labelled vector could easily be converted to a factor with <code>to_factor</code>.</p>

<pre><code class="r">v &lt;- labelled(c(1,2,2,2,3,9,1,3,2,NA), c(yes = 1, no = 3, &quot;don&#39;t know&quot; = 8, refused = 9))
v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value      label
##      1        yes
##      3         no
##      8 don&#39;t know
##      9    refused
</code></pre>

<pre><code class="r">to_factor(v)
</code></pre>

<pre><code>##  [1] yes     2       2       2       no      refused yes     no     
##  [9] 2       &lt;NA&gt;   
## Levels: yes 2 no don&#39;t know refused
</code></pre>

<p>The <code>levels</code> argument allows to specify what should be used as the factor levels, 
i.e. the labels (default), the values or the labels prefixed with values.</p>

<pre><code class="r">to_factor(v, levels = &quot;v&quot;)
</code></pre>

<pre><code>##  [1] 1    2    2    2    3    9    1    3    2    &lt;NA&gt;
## Levels: 1 2 3 8 9
</code></pre>

<pre><code class="r">to_factor(v, levels = &quot;p&quot;)
</code></pre>

<pre><code>##  [1] [1] yes     [2] 2       [2] 2       [2] 2       [3] no     
##  [6] [9] refused [1] yes     [3] no      [2] 2       &lt;NA&gt;       
## Levels: [1] yes [2] 2 [3] no [8] don&#39;t know [9] refused
</code></pre>

<p>The <code>ordered</code> argument will create an ordinal factor.</p>

<pre><code class="r">to_factor(v, ordered = TRUE)
</code></pre>

<pre><code>##  [1] yes     2       2       2       no      refused yes     no     
##  [9] 2       &lt;NA&gt;   
## Levels: yes &lt; 2 &lt; no &lt; don&#39;t know &lt; refused
</code></pre>

<p>The argument <code>nolabel_to_na</code> specify if the corresponding function should be 
applied before converting to a factor. Therefore, the two following commands are equivalent.</p>

<pre><code class="r">to_factor(v, nolabel_to_na = TRUE)
</code></pre>

<pre><code>##  [1] yes     &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    no      refused yes     no     
##  [9] &lt;NA&gt;    &lt;NA&gt;   
## Levels: yes no don&#39;t know refused
</code></pre>

<pre><code class="r">to_factor(nolabel_to_na(v))
</code></pre>

<pre><code>##  [1] yes     &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    no      refused yes     no     
##  [9] &lt;NA&gt;    &lt;NA&gt;   
## Levels: yes no don&#39;t know refused
</code></pre>

<p><code>sort_levels</code> specifies how the levels should be sorted: <code>&quot;none&quot;</code> to keep the order in which value labels 
have been defined, <code>&quot;values&quot;</code> to order the levels according to the values and <code>&quot;labels&quot;</code> according 
to the labels. <code>&quot;auto&quot;</code> (default) will be equivalent to <code>&quot;none&quot;</code> except if some values with no 
attached labels are found and are not dropped. In that case, <code>&quot;values&quot;</code> will be used.</p>

<pre><code class="r">to_factor(v, sort_levels = &quot;n&quot;)
</code></pre>

<pre><code>##  [1] yes     2       2       2       no      refused yes     no     
##  [9] 2       &lt;NA&gt;   
## Levels: yes no don&#39;t know refused 2
</code></pre>

<pre><code class="r">to_factor(v, sort_levels = &quot;v&quot;)
</code></pre>

<pre><code>##  [1] yes     2       2       2       no      refused yes     no     
##  [9] 2       &lt;NA&gt;   
## Levels: yes 2 no don&#39;t know refused
</code></pre>

<pre><code class="r">to_factor(v, sort_levels = &quot;l&quot;)
</code></pre>

<pre><code>##  [1] yes     2       2       2       no      refused yes     no     
##  [9] 2       &lt;NA&gt;   
## Levels: 2 don&#39;t know no refused yes
</code></pre>

<p>The function <code>to_labelled</code> could be used to turn a factor into a labelled numeric vector. </p>

<pre><code class="r">f &lt;- factor(1:3, labels = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
to_labelled(f)
</code></pre>

<pre><code>## &lt;Labelled double&gt;
## [1] 1 2 3
## 
## Labels:
##  value label
##      1     a
##      2     b
##      3     c
</code></pre>

<p>Note that <code>to_labelled(to_factor(v))</code> will not be equal to <code>v</code> due to the way factors are
stored internally by <strong>R</strong>.</p>

<pre><code class="r">v
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  9  1  3  2 NA
## 
## Labels:
##  value      label
##      1        yes
##      3         no
##      8 don&#39;t know
##      9    refused
</code></pre>

<pre><code class="r">to_labelled(to_factor(v))
</code></pre>

<pre><code>## &lt;Labelled double&gt;
##  [1]  1  2  2  2  3  5  1  3  2 NA
## 
## Labels:
##  value      label
##      1        yes
##      2          2
##      3         no
##      4 don&#39;t know
##      5    refused
</code></pre>

<h2>Importing labelled data</h2>

<p>In <strong>haven</strong> package, <code>read_spss</code>, <code>read_stata</code> and <code>read_sas</code> are natively importing data
using the <code>labelled</code> class and the <code>label</code> attribute for variable labels.</p>

<p>Functions from <strong>foreign</strong> package could also import some metadata from <strong>SPSS</strong> and <strong>Stata</strong>
files. <code>to_labelled</code> can convert data imported with <strong>foreign</strong> into a labelled data frame.
However, there are some limitations compared to using <strong>haven</strong>:</p>

<ul>
<li>For <strong>SPSS</strong> files, it will be better to set <code>use.value.labels = FALSE</code>, <code>to.data.frame = FALSE</code> and
<code>use.missings = FALSE</code> when calling <code>read.spss</code>. If <code>use.value.labels = TRUE</code>, variable with
value labels will be converted into factors by <code>read.spss</code> (and kept as factors by <code>foreign_to_label</code>). 
If <code>to.data.frame = TRUE</code>, meta data describing the missing values will not be imported. 
If <code>use.missings = TRUE</code>, missing values would have been converted to <code>NA</code> by <code>read.spss</code>.</li>
<li>For <strong>Stata</strong> files, set <code>convert.factors = FALSE</code> when calling <code>read.dta</code> to avoid conversion
of variables with value labels into factors. So far, missing values defined in Stata are always 
imported as <code>NA</code> by <code>read.dta</code> and could not be retrieved by <code>foreign_to_labelled</code>.</li>
</ul>

<p>The <strong>memisc</strong> package provide functions to import variable metadata and store them in specific
object of class <code>data.set</code>. The <code>to_labelled</code> method can convert a data.set into a labelled data frame.</p>

<pre><code class="r">  # from foreign
  library(foreign)
  df &lt;- to_labelled(read.spss(
    &quot;file.sav&quot;,
    to.data.frame = FALSE,
    use.value.labels = FALSE,
    use.missings = FALSE
 ))
 df &lt;- to_labelled(read.dta(
   &quot;file.dta&quot;,
   convert.factors = FALSE
 ))

 # from memisc
 library(memisc)
 nes1948.por &lt;- UnZip(&quot;anes/NES1948.ZIP&quot;, &quot;NES1948.POR&quot;, package=&quot;memisc&quot;)
 nes1948 &lt;- spss.portable.file(nes1948.por)
 df &lt;- to_labelled(nes1948)
 ds &lt;- as.data.set(nes19480)
 df &lt;- to_labelled(ds)
</code></pre>

<h2>Using labelled with dplyr/magrittr</h2>

<p>If you are using the <code>%&gt;%</code> operator, you can use the functions <code>set_variable_labels</code>, <code>set_value_labels</code>,
<code>add_value_labels</code> and <code>remove_value_labels</code>.</p>

<pre><code class="r">library(dplyr)
</code></pre>

<pre><code>## 
## Attaching package: &#39;dplyr&#39;
</code></pre>

<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag
</code></pre>

<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union
</code></pre>

<pre><code class="r">df &lt;- data_frame(s1 = c(&quot;M&quot;, &quot;M&quot;, &quot;F&quot;), s2 = c(1, 1, 2)) %&gt;% 
  set_variable_labels(s1 = &quot;Sex&quot;, s2 = &quot;Question&quot;) %&gt;%
  set_value_labels(s1 = c(Male = &quot;M&quot;, Female = &quot;F&quot;), s2 = c(Yes = 1, No = 2))
df$s2
</code></pre>

<pre><code>## &lt;Labelled double&gt;
## [1] 1 1 2
## 
## Labels:
##  value label
##      1   Yes
##      2    No
</code></pre>

<p><code>set_value_labels</code> will replace the list of value labels while <code>add_value_labels</code> will update it.</p>

<pre><code class="r">df &lt;- df %&gt;%
  set_value_labels(s2 = c(Yes = 1, &quot;Don&#39;t know&quot; = 8, Unknown = 9))
df$s2
</code></pre>

<pre><code>## &lt;Labelled double&gt;
## [1] 1 1 2
## 
## Labels:
##  value      label
##      1        Yes
##      8 Don&#39;t know
##      9    Unknown
</code></pre>

<pre><code class="r">df &lt;- df %&gt;%
  add_value_labels(s2 = c(No = 2))
df$s2
</code></pre>

<pre><code>## &lt;Labelled double&gt;
## [1] 1 1 2
## 
## Labels:
##  value      label
##      1        Yes
##      8 Don&#39;t know
##      9    Unknown
##      2         No
</code></pre>

<p>You can also remove some variable and/or value labels.</p>

<pre><code class="r">df &lt;- df %&gt;%
  set_variable_labels(s1 = NULL)

# removing one value label
df &lt;- df %&gt;%
  remove_value_labels(s2 = 2)
df$s2
</code></pre>

<pre><code>## &lt;Labelled double&gt;
## [1] 1 1 2
## 
## Labels:
##  value      label
##      1        Yes
##      8 Don&#39;t know
##      9    Unknown
</code></pre>

<pre><code class="r"># removing several value labels
df &lt;- df %&gt;%
  remove_value_labels(s2 = 8:9)
df$s2
</code></pre>

<pre><code>## &lt;Labelled double&gt;
## [1] 1 1 2
## 
## Labels:
##  value label
##      1   Yes
</code></pre>

<pre><code class="r"># removing all value labels
df &lt;- df %&gt;%
  set_value_labels(s2 = NULL)
df$s2
</code></pre>

<pre><code>## [1] 1 1 2
## attr(,&quot;label&quot;)
## [1] &quot;Question&quot;
</code></pre>

</body>

</html>
