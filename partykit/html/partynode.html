<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Inner and Terminal Nodes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for partynode {partykit}"><tr><td>partynode {partykit}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Inner and Terminal Nodes </h2>

<h3>Description</h3>

<p>A class for representing inner and terminal 
nodes in trees and functions for data partitioning.
</p>


<h3>Usage</h3>

<pre>
partynode(id, split = NULL, kids = NULL, surrogates = NULL, 
    info = NULL)
kidids_node(node, data, vmatch = 1:ncol(data), 
    obs = NULL, perm = NULL)
fitted_node(node, data, vmatch = 1:ncol(data), 
    obs = 1:nrow(data), perm = NULL)
id_node(node)
split_node(node)
surrogates_node(node)
kids_node(node)
info_node(node)
formatinfo_node(node, FUN = NULL, default = "", prefix = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>id</code></td>
<td>
<p> integer, a unique identifier for a node. </p>
</td></tr>
<tr valign="top"><td><code>split</code></td>
<td>
<p> an object of class <code><a href="partysplit.html">partysplit</a></code>. </p>
</td></tr>
<tr valign="top"><td><code>kids</code></td>
<td>
<p> a list of <code>partynode</code> objects. </p>
</td></tr>
<tr valign="top"><td><code>surrogates</code></td>
<td>
<p> a list of <code>partysplit</code> objects.</p>
</td></tr>
<tr valign="top"><td><code>info</code></td>
<td>
<p> additional information. </p>
</td></tr>
<tr valign="top"><td><code>node</code></td>
<td>
<p> an object of class <code>partynode</code>.</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
<p> a <code><a href="../../base/html/list.html">list</a></code> or <code><a href="../../base/html/data.frame.html">data.frame</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>vmatch</code></td>
<td>
<p> a permutation of the variable numbers in <code>data</code>.</p>
</td></tr>
<tr valign="top"><td><code>obs</code></td>
<td>
<p> a logical or integer vector indicating a subset of the
observations in <code>data</code>.</p>
</td></tr>
<tr valign="top"><td><code>perm</code></td>
<td>
<p> a vector of integers specifying the variables
to be permuted prior before splitting (i.e., for
computing permutation variable importances). The
default <code>NULL</code> doesn't alter the data.</p>
</td></tr>
<tr valign="top"><td><code>FUN</code></td>
<td>
<p> function for formatting the <code>info</code>, for default see below.</p>
</td></tr>
<tr valign="top"><td><code>default</code></td>
<td>
<p> a character used if the <code>info</code> in <code>node</code>
is <code>NULL</code>.</p>
</td></tr>
<tr valign="top"><td><code>prefix</code></td>
<td>
<p> an optional prefix to be added to the returned character. </p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p> further arguments passed to
<code><a href="../../utils/html/capture.output.html">capture.output</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A node represents both inner and terminal nodes in a tree structure. 
Each node has a unique identifier <code>id</code>. A node consisting only
of such an identifier (and possibly additional information
in <code>info</code>) is a terminal node.
</p>
<p>Inner nodes consist of a primary split 
(an object of class <code><a href="partysplit.html">partysplit</a></code>)
and at least two kids (daughter nodes). 
Kid nodes are objects of class <code>partynode</code>
itself, so the tree structure is defined recursively.
In addition, a list of <code>partysplit</code> objects 
offering surrogate splits can be supplied. Like
<code><a href="partysplit.html">partysplit</a></code> objects, <code>partynode</code>
objects aren't connected to the actual data.
</p>
<p>Function <code>kidids_node()</code> determines how
the observations in <code>data[obs,]</code> are partitioned
into the kid nodes and returns the number of the list element
in list <code>kids</code> each observations belongs to 
(and not it's identifier).
This is done by evaluating <code>split</code> (and possibly
all surrogate splits) on <code>data</code> using 
<code><a href="partysplit.html">kidids_split</a></code>.
</p>
<p>Function <code>fitted_node()</code> performs all 
splits recursively and returns the identifier <code>id</code>
of the terminal node each observation in
<code>data[obs,]</code> belongs to. Arguments <code>vmatch</code>, 
<code>obs</code> and <code>perm</code> are passed to <code><a href="partysplit.html">kidids_split</a></code>.
</p>
<p>Function <code>formatinfo_node()</code> extracts the the <code>info</code>
from <code>node</code> and formats it to a <code>character</code> vector using the following
strategy: If <code>is.null(info)</code>, the <code>default</code> is returned.  
Otherwise, <code>FUN</code> is applied for formatting. The default function uses
<code>as.character</code> for atomic objects and applies <code><a href="../../utils/html/capture.output.html">capture.output</a></code>
to <code>print(info)</code> for other objects. Optionally, a <code>prefix</code> can be added
to the computed character string.
</p>
<p>All other functions are accessor functions for
extracting information from objects of class <code>partynode</code>.
</p>


<h3>Value</h3>

<p>The constructor <code>partynode()</code> returns an object of class <code>partynode</code>:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>id</code></td>
<td>
<p> a unique integer identifier for a node. </p>
</td></tr>
<tr valign="top"><td><code>split</code></td>
<td>
<p> an object of class <code><a href="partysplit.html">partysplit</a></code>. </p>
</td></tr>
<tr valign="top"><td><code>kids</code></td>
<td>
<p> a list of <code>partynode</code> objects. </p>
</td></tr>
<tr valign="top"><td><code>surrogates</code></td>
<td>
<p> a list of <code><a href="partysplit.html">partysplit</a></code> objects.</p>
</td></tr>
<tr valign="top"><td><code>info</code></td>
<td>
<p> additional information. </p>
</td></tr>
</table>
<p><code>kidids_split()</code> returns an integer vector describing
the partition of the observations into kid nodes by their position
in list <code>kids</code>.
</p>
<p><code>fitted_node()</code> returns the node identifiers (<code>id</code>) 
of the terminal nodes each observation belongs to.
</p>


<h3>References</h3>

 
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905&ndash;3909.
</p>


<h3>Examples</h3>

<pre>
data("iris", package = "datasets")

## a stump defined by a binary split in Sepal.Length
stump &lt;- partynode(id = 1L, 
    split = partysplit(which(names(iris) == "Sepal.Length"),
	breaks = 5),
    kids = lapply(2:3, partynode))

## textual representation
print(stump, data = iris)  

## list element number and node id of the two terminal nodes
table(kidids_node(stump, iris), 
    fitted_node(stump, data = iris))

## assign terminal nodes with probability 0.5
## to observations with missing `Sepal.Length'
iris_NA &lt;- iris
iris_NA[sample(1:nrow(iris), 50), "Sepal.Length"] &lt;- NA
table(fitted_node(stump, data = iris_NA, 
    obs = !complete.cases(iris_NA)))

## a stump defined by a primary split in `Sepal.Length'
## and a surrogate split in `Sepal.Width' which
## determines terminal nodes for observations with
## missing `Sepal.Length'
stump &lt;- partynode(id = 1L, 
    split = partysplit(which(names(iris) == "Sepal.Length"),
	breaks = 5),
    kids = lapply(2:3, partynode),
    surrogates = list(partysplit(
	which(names(iris) == "Sepal.Width"), breaks = 3)))
f &lt;- fitted_node(stump, data = iris_NA, 
    obs = !complete.cases(iris_NA))
tapply(iris_NA$Sepal.Width[!complete.cases(iris_NA)], f, range)

</pre>

<hr /><div style="text-align: center;">[Package <em>partykit</em> version 1.2-12 <a href="00Index.html">Index</a>]</div>
</body></html>
